#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r16ui) uniform uimage3D block_data_atlas;
layout(set = 0, binding = 1, r16ui) uniform uimage3D chunk_map;
layout(set = 0, binding = 2, r16ui) uniform uimage3D region_map;
layout(set = 0, binding = 3, rgba8_snorm) uniform writeonly image2D final_output;

layout(push_constant) uniform CameraVectors {
    vec3 origin, forward, up, right;
} camera_vectors;

const uint CHUNK_BLOCK_WIDTH = 8;
const uint CHUNK_BLOCK_VOLUME = CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint REGION_CHUNK_WIDTH = 8;
const uint REGION_BLOCK_WIDTH = REGION_CHUNK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint ROOT_REGION_WIDTH = 8;
const uint ROOT_REGION_VOLUME = ROOT_REGION_WIDTH * ROOT_REGION_WIDTH * ROOT_REGION_WIDTH;
const uint ROOT_CHUNK_WIDTH = ROOT_REGION_WIDTH * REGION_CHUNK_WIDTH;
const uint ROOT_CHUNK_VOLUME = ROOT_CHUNK_WIDTH * ROOT_CHUNK_WIDTH * ROOT_CHUNK_WIDTH;
const uint ROOT_BLOCK_WIDTH = ROOT_CHUNK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint ATLAS_CHUNK_WIDTH = 32; 
const uint ATLAS_BLOCK_WIDTH = ATLAS_CHUNK_WIDTH * CHUNK_BLOCK_WIDTH;
const uint ATLAS_CHUNK_VOLUME = ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH;

const uint EMPTY_CHUNK_INDEX = 0xFFFF;
const uint UNLOADED_CHUNK_INDEX = 0xFFFE;
const uint REQUEST_LOAD_CHUNK_INDEX = 0xFFFD;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;

const float PI = 3.1415926535897932384626433832795;

struct HitResult {
    uint value;
    vec3 position;
    float distance;
    uint normal;
};

#define PERFORM_BLOCK_STEP(AXIS) \
    block_coord.AXIS += step.AXIS; \
    total_step = next_block_distance.AXIS; \
    if (block_coord.AXIS == CHUNK_BLOCK_WIDTH || block_coord.AXIS == -1) { break; } \
    result.value = imageLoad(block_data_atlas, block_coord + atlas_offset * ivec3(CHUNK_BLOCK_WIDTH)).r; \
    if (result.value != 0) { \
        result.normal = int(NORMAL_##AXIS) + (step.AXIS + 1) / 2;\
        break; \
    } \
    next_block_distance.AXIS += block_advance_amount.AXIS;

#define PERFORM_CHUNK_TRACE(AXIS) \
    vec3 real_pos = origin + direction * total_step; \
    vec3 fake_pos = real_pos; \
    fake_pos.AXIS += step.AXIS * 0.01; \
    block_coord = ivec3(floor(fake_pos)); \
    \
    if (step.x == 1) { \
        next_block_distance.x = (block_coord.x + 1 - real_pos.x) * block_advance_amount.x; \
    } else { \
        next_block_distance.x = (real_pos.x - block_coord.x) * block_advance_amount.x; \
    } \
    if (step.y == 1) { \
        next_block_distance.y = (block_coord.y + 1 - real_pos.y) * block_advance_amount.y; \
    } else { \
        next_block_distance.y = (real_pos.y - block_coord.y) * block_advance_amount.y; \
    } \
    if (step.z == 1) { \
        next_block_distance.z = (block_coord.z + 1 - real_pos.z) * block_advance_amount.z; \
    } else { \
        next_block_distance.z = (real_pos.z - block_coord.z) * block_advance_amount.z; \
    } \
    next_block_distance += vec3(total_step); \
    block_coord %= ivec3(CHUNK_BLOCK_WIDTH); \
    result.value = imageLoad(block_data_atlas, block_coord + atlas_offset * ivec3(CHUNK_BLOCK_WIDTH)).r; \
    result.value = 1; \
    if (result.value == 0) { for (int i = 0; i < 32; i++) { \
        if (next_block_distance.x < next_block_distance.y) { \
            if (next_block_distance.x < next_block_distance.z) { \
                PERFORM_BLOCK_STEP(x); \
            } else { \
                PERFORM_BLOCK_STEP(z); \
            } \
        } else { \
            if (next_block_distance.y < next_block_distance.z) { \
                PERFORM_BLOCK_STEP(y); \
            } else { \
                PERFORM_BLOCK_STEP(z); \
            } \
        } \
    } } else { \
        result.normal = int(NORMAL_##AXIS) + (step.AXIS + 1) / 2; \
    }

#define PERFORM_CHUNK_STEP(AXIS) \
    chunk_coord.AXIS += step.AXIS; \
    total_step = next_chunk_distance.AXIS; \
    if (chunk_coord.AXIS == region_exit_planes.AXIS) { break; } \
    chunk_index = imageLoad(chunk_map, chunk_coord).r; \
    if (chunk_index == UNLOADED_CHUNK_INDEX) { \
        imageStore(region_map, region_coord, ivec4(REQUEST_LOAD_CHUNK_INDEX)); \
        imageStore(chunk_map, chunk_coord, ivec4(REQUEST_LOAD_CHUNK_INDEX)); \
        result.value = UNLOADED_CHUNK_INDEX; \
        break; \
    } else if (chunk_index == REQUEST_LOAD_CHUNK_INDEX) { \
        result.value = UNLOADED_CHUNK_INDEX; \
        break; \
    } else if (chunk_index != EMPTY_CHUNK_INDEX) { \
        atlas_offset.x = int(chunk_index % ATLAS_CHUNK_WIDTH); \
        atlas_offset.y = int(chunk_index / ATLAS_CHUNK_WIDTH % ATLAS_CHUNK_WIDTH); \
        atlas_offset.z = int(chunk_index / ATLAS_CHUNK_WIDTH / ATLAS_CHUNK_WIDTH); \
        PERFORM_CHUNK_TRACE(AXIS) \
    } \
    if (result.value != 0) { break; } \
    next_chunk_distance.AXIS += chunk_advance_amount.AXIS;

#define PERFORM_REGION_TRACE(AXIS) \
    vec3 real_pos = origin + direction * total_step; \
    vec3 fake_pos = real_pos; \
    fake_pos.AXIS += step.AXIS * 0.01; \
    block_coord = ivec3(floor(fake_pos)); \
    chunk_coord = block_coord / ivec3(CHUNK_BLOCK_WIDTH); \
    real_pos /= vec3(CHUNK_BLOCK_WIDTH); \
    vec3 next_chunk_distance = vec3(0); \
    if (step.x == 1) { \
        next_chunk_distance.x = (chunk_coord.x + 1 - real_pos.x) * chunk_advance_amount.x; \
        region_exit_planes.x = int((region_coord.x + 1) * REGION_CHUNK_WIDTH); \
    } else { \
        next_chunk_distance.x = (real_pos.x - chunk_coord.x) * chunk_advance_amount.x; \
        region_exit_planes.x = int(region_coord.x * REGION_CHUNK_WIDTH) - 1; \
    } \
    if (step.y == 1) { \
        next_chunk_distance.y = (chunk_coord.y + 1 - real_pos.y) * chunk_advance_amount.y; \
        region_exit_planes.y = int((region_coord.y + 1) * REGION_CHUNK_WIDTH); \
    } else { \
        next_chunk_distance.y = (real_pos.y - chunk_coord.y) * chunk_advance_amount.y; \
        region_exit_planes.y = int(region_coord.y * REGION_CHUNK_WIDTH) - 1; \
    } \
    if (step.z == 1) { \
        next_chunk_distance.z = (chunk_coord.z + 1 - real_pos.z) * chunk_advance_amount.z; \
        region_exit_planes.z = int((region_coord.z + 1) * REGION_CHUNK_WIDTH); \
    } else { \
        next_chunk_distance.z = (real_pos.z - chunk_coord.z) * chunk_advance_amount.z; \
        region_exit_planes.z = int(region_coord.z * REGION_CHUNK_WIDTH) - 1; \
    } \
    next_chunk_distance += vec3(total_step); \
    \
    result.value = 0; \
    chunk_index = imageLoad(chunk_map, chunk_coord).r; \
    if (chunk_index == UNLOADED_CHUNK_INDEX) { \
        imageStore(chunk_map, chunk_coord, ivec4(REQUEST_LOAD_CHUNK_INDEX)); \
        imageStore(region_map, region_coord, ivec4(REQUEST_LOAD_CHUNK_INDEX)); \
        result.value = UNLOADED_CHUNK_INDEX; \
        break; \
    } else if (chunk_index == REQUEST_LOAD_CHUNK_INDEX) { \
        result.value = UNLOADED_CHUNK_INDEX; \
        break; \
    } else { \
        if (chunk_index != EMPTY_CHUNK_INDEX) { \
            atlas_offset.x = int(chunk_index % ATLAS_CHUNK_WIDTH); \
            atlas_offset.y = int(chunk_index / ATLAS_CHUNK_WIDTH % ATLAS_CHUNK_WIDTH); \
            atlas_offset.z = int(chunk_index / ATLAS_CHUNK_WIDTH / ATLAS_CHUNK_WIDTH); \
            PERFORM_CHUNK_TRACE(x); \
        } \
        if (result.value == 0) { for (int i = 0; i < 32; i++) { \
            if (next_chunk_distance.x < next_chunk_distance.y) { \
                if (next_chunk_distance.x < next_chunk_distance.z) { \
                    PERFORM_CHUNK_STEP(x); \
                } else { \
                    PERFORM_CHUNK_STEP(z); \
                } \
            } else { \
                if (next_chunk_distance.y < next_chunk_distance.z) { \
                    PERFORM_CHUNK_STEP(y); \
                } else { \
                    PERFORM_CHUNK_STEP(z); \
                } \
            } \
        } } \
    }

#define PERFORM_REGION_STEP(AXIS) \
    region_coord.AXIS += step.AXIS; \
    total_step = next_region_distance.AXIS; \
    if (region_coord.AXIS < 0 || region_coord.AXIS == ROOT_REGION_WIDTH) { break; } \
    region_content = imageLoad(region_map, region_coord).r; \
    if (region_content == UNLOADED_CHUNK_INDEX) { \
        imageStore(region_map, region_coord, ivec4(REQUEST_LOAD_CHUNK_INDEX)); \
        break; \
    } else if (region_content != EMPTY_CHUNK_INDEX) { \
        PERFORM_REGION_TRACE(AXIS); \
    } \
    if (result.value != 0) { break; } \
    next_region_distance.AXIS += region_advance_amount.AXIS;

HitResult trace_ray(vec3 origin, vec3 direction) {
    HitResult result;
    float total_step = 0.0;
    ivec3 block_coord, chunk_coord, region_coord, atlas_offset;
    ivec3 region_exit_planes;
    vec3 next_piece_distance, next_block_distance, next_region_distance;
    uint chunk_index, region_content;

    region_coord = ivec3(floor(origin / REGION_BLOCK_WIDTH));

    ivec3 step = ivec3(
        direction.x < 0 ? -1 : 1,
        direction.y < 0 ? -1 : 1,
        direction.z < 0 ? -1 : 1
    );
    // How much we need to move along the vector to advance the current block 
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 block_advance_amount = abs(vec3(
        1.0 / (direction.x + 1e-8),
        1.0 / (direction.y + 1e-8),
        1.0 / (direction.z + 1e-8)
    ));
    vec3 chunk_advance_amount = block_advance_amount * vec3(CHUNK_BLOCK_WIDTH);
    vec3 region_advance_amount = block_advance_amount * vec3(REGION_BLOCK_WIDTH);

    if (step.x == 1) {
        next_region_distance.x = (region_coord.x + 1 - origin.x / REGION_BLOCK_WIDTH) * region_advance_amount.x;
    } else {
        next_region_distance.x = (origin.x / REGION_BLOCK_WIDTH - region_coord.x) * region_advance_amount.x;
    }
    if (step.y == 1) {
        next_region_distance.y = (region_coord.y + 1 - origin.y / REGION_BLOCK_WIDTH) * region_advance_amount.y;
    } else {
        next_region_distance.y = (origin.y / REGION_BLOCK_WIDTH - region_coord.y) * region_advance_amount.y;
    }
    if (step.z == 1) {
        next_region_distance.z = (region_coord.z + 1 - origin.z / REGION_BLOCK_WIDTH) * region_advance_amount.z;
    } else {
        next_region_distance.z = (origin.z / REGION_BLOCK_WIDTH - region_coord.z) * region_advance_amount.z;
    }

    result.value = 0;
    region_content = imageLoad(region_map, region_coord).r;
    if (region_content == UNLOADED_CHUNK_INDEX) {
        imageStore(region_map, region_coord, ivec4(REQUEST_LOAD_CHUNK_INDEX));
    } else if (region_content == REQUEST_LOAD_CHUNK_INDEX) {
    } else {
        if (region_content != EMPTY_CHUNK_INDEX) {
            do { PERFORM_REGION_TRACE(x); } while (false);
        }
        if (result.value == 0) { for (int i = 0; i < 32; i++) {
            if (next_region_distance.x < next_region_distance.y) {
                if (next_region_distance.x < next_region_distance.z) {
                    PERFORM_REGION_STEP(x);
                } else {
                    PERFORM_REGION_STEP(z);
                }
            } else {
                if (next_region_distance.y < next_region_distance.z) {
                    PERFORM_REGION_STEP(y);
                } else {
                    PERFORM_REGION_STEP(z);
                }
            }
        } }
    }

    if (result.value == UNLOADED_CHUNK_INDEX) {
        result.value = 0;
    }

    result.distance = total_step;
    result.position = origin + direction * total_step;

    if (result.normal == NORMAL_x) {
        result.position += vec3(0.02, 0, 0);
    } else if (result.normal == NORMAL_x + 1) {
        result.position -= vec3(0.02, 0, 0);
    } else if (result.normal == NORMAL_y) {
        result.position += vec3(0, 0.02, 0);
    } else if (result.normal == NORMAL_y + 1) {
        result.position -= vec3(0, 0.02, 0);
    } else if (result.normal == NORMAL_z) {
        result.position += vec3(0, 0, 0.02);
    } else if (result.normal == NORMAL_z + 1) {
        result.position -= vec3(0, 0, 0.02);
    }

    return result;
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

HitResult trace_sun(HitResult from, vec3 direction) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    return trace_ray(from.position, normalize(direction + vec3(r1, r2, 0) * 0.05));
}

HitResult trace_diffuse(HitResult from) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    float theta1 = PI * 2.0 * r1;
    float theta2 = acos(1.0 - 2.0 * r2);
    // Random point on sphere.
    vec3 direction = vec3(
        sin(theta1) * sin(theta2),
        cos(theta1) * sin(theta2),
        cos(theta2)
    );
    if (from.normal == NORMAL_x) {
        direction += vec3(1, 0, 0);
    } else if (from.normal == NORMAL_x + 1) {
        direction -= vec3(1, 0, 0);
    } else if (from.normal == NORMAL_y) {
        direction += vec3(0, 1, 0);
    } else if (from.normal == NORMAL_y + 1) {
        direction -= vec3(0, 1, 0);
    } else if (from.normal == NORMAL_z) {
        direction += vec3(0, 0, 1);
    } else if (from.normal == NORMAL_z + 1) {
        direction -= vec3(0, 0, 1);
    }
    return trace_ray(from.position, normalize(direction));
}

vec3 get_material_albedo(uint material) {
    switch (material) {
        case 0:
        return vec3(1, 0, 1);
        case 1:
        return vec3(0.8);
        case 2:
        return vec3(0.4, 0.3, 0.2);
        case 3:
        return vec3(0.2, 0.8, 0.2);
        case 4:
        return vec3(0.2, 0.4, 0.9);
        case 5:
        return vec3(0.2, 0.8, 0.7);
        case 6:
        return vec3(0.9, 0.7, 0.2);
        case 7:
        return vec3(0.8, 0.2, 0.7);
        case 8:
        return vec3(0.2, 0.2, 0.2);
    }
}

vec3 get_material_emission(uint material) {
    switch (material) {
        case 0:
        return vec3(0);
        case 1:
        return vec3(0);
        case 2:
        return vec3(1.9, 0.8, 0.4);
        case 3:
        return vec3(0);
        case 4:
        return vec3(0);
        case 5:
        return vec3(0);
        case 6:
        return vec3(0);
        case 7:
        return vec3(0);
        case 8:
        return vec3(0);
    }
}

vec3 debug_normal(uint normal) {
    vec3 color = vec3(1);
    if (normal % 2 == 1) {
        normal -= 1;
        color *= 0.5;
    }
    if (normal == NORMAL_x) {
        color *= vec3(1, 0, 0);
    } else if (normal == NORMAL_y) {
        color *= vec3(0, 1, 0);
    } else if (normal == NORMAL_z) {
        color *= vec3(0, 0, 1);
    }
    return color;
}

void main() {
    vec3 ray_start = camera_vectors.origin;

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(imageSize(final_output)) * 2.0 - vec2(1);
    // Must be normalized. 
    vec3 ray_direction = normalize(
        camera_vectors.forward
        + screen_pos.x * camera_vectors.right
        + screen_pos.y * camera_vectors.up
    );

    vec3 skylight = vec3(0.2, 0.4, 0.8);
    vec3 sunlight = vec3(0.6);
    vec3 sunangle = vec3(1, 2, 1);
    vec3 color = skylight;
    HitResult primary = trace_ray(camera_vectors.origin, ray_direction);
    if (true) { color = get_material_albedo(primary.value); } else 
    if (primary.value > 0) {
        color = vec3(0.0);
        vec3 albedo1 = get_material_albedo(primary.value);
        HitResult sun1 = trace_sun(primary, sunangle);
        if (sun1.value == 0) {
            color += albedo1 * sunlight;
        }
        HitResult dif1 = trace_diffuse(primary);
        if (dif1.value == 0) {
            color += albedo1 * skylight;
        } else {
            vec3 color2 = vec3(0.0);
            vec3 albedo2 = get_material_albedo(dif1.value);
            HitResult sun2 = trace_sun(dif1, sunangle);
            if (sun2.value == 0) {
                color2 += albedo2 * sunlight;
            }
            HitResult dif2 = trace_diffuse(dif1);
            if (dif2.value == 0) {
                color2 += albedo2 * skylight;
            } else {
                // vec3 color3 = vec3(0.0);
                // vec3 albedo3 = get_material_albedo(dif2.value);
                // HitResult sun3 = trace_sun(dif2, sunangle);
                // if (sun3.value == 0) {
                    // color3 += albedo3 * sunlight;
                // }
                // HitResult dif3 = trace_diffuse(dif1);
                // if (dif3.value == 0) {
                    // color3 += albedo3 * skylight;
                // }
                // color3 += get_material_emission(dif2.value);
                // color2 += albedo2 * color3;
            }
            color2 += get_material_emission(dif1.value);
            color += albedo1 * color2;
        }
        color += get_material_emission(primary.value);
    }

    imageStore(
        final_output,
        ivec2(gl_GlobalInvocationID.xy), 
        vec4(color, 1.0)
    );
}

/*
void main() {
    uint index = imageLoad(chunk_map, ivec3(
        gl_GlobalInvocationID.x / 4 % ROOT_CHUNK_WIDTH,
        gl_GlobalInvocationID.x / 4 / ROOT_CHUNK_WIDTH % ROOT_CHUNK_WIDTH,
        gl_GlobalInvocationID.y / 4 % ROOT_CHUNK_WIDTH
    )).r;
    if (index > 64) index = 64;
    imageStore(
        final_output,
        ivec2(gl_GlobalInvocationID.xy), 
        vec4(vec3(index) / 64.0, 1.0)
    );
}
*/