#version 450

#include "GEN_MATERIALS.glsl"

// If defined, a limiter will be applied to terminate any ray trace that takes too long. The pixel
// the ray trace occured for will be highlighted in pink.
#define REPORT_ERROR

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform usampler3D world;
layout(set = 0, binding = 1) uniform usampler3D minefield;

layout(set = 0, binding = 2, rgba8) uniform writeonly image2D albedo_buffer;
layout(set = 0, binding = 3, rgba8) uniform writeonly image2D emission_buffer;
layout(set = 0, binding = 4, rgba8) uniform writeonly image2D fog_color_buffer;

layout(set = 0, binding = 5, rgba16) uniform writeonly image2D lighting_buffer;
layout(set = 0, binding = 6, rgba16) uniform writeonly image2D completed_buffer;
layout(set = 0, binding = 7, r8ui) uniform writeonly uimage2D normal_buffer;
layout(set = 0, binding = 8, r16ui) uniform writeonly uimage2D depth_buffer;

layout(set = 0, binding = 9) uniform sampler2D blue_noise;
layout(set = 0, binding = 10) uniform UniformData {
    float sun_angle;
    uint seed;
    vec3 origin, forward, up, right;
    // For some reason doing mat3 still loads 16 elements but the rust bindings give it 9, making
    // the whole thing go out of order. So transmit each individual column instead.
    vec3 old_origin, old_transform_c0, old_transform_c1, old_transform_c2;
    ivec3 region_offset;
} uniform_data;

layout(set = 0, binding = 11) uniform usampler3D minefield_lod1;

const uint ROOT_BLOCK_WIDTH = 256;

const uint EMPTY_CHUNK_INDEX = 0xFFFF;
const uint UNLOADED_CHUNK_INDEX = 0xFFFE;
const uint REQUEST_LOAD_CHUNK_INDEX = 0xFFFD;

const uint NOISE_SIZE = 512;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;

// Gap between each pixel that a particular thread group computes.
// E.G. if a 4x4 group uses a spread value of 2, it will compute the first, third, fifth,
// and seventh pixels relative to its start location. The thread group directly to the right of it
// will compute the second, fourth, sixth, and eighth. The next thread group to the right will
// start on the ninth pixel, and so on.
const uint PIXEL_SPREAD = 16;
// Lighting values are divided by this before being added to the lighting buffer. This gives
// room for HDR and accumulation of multiple samples.
const float LIGHTING_SCALE = 16.0;
const uint MAX_SAMPLES = 8;

const float PI = 3.1415926535897932384626433832795;

struct HitResult {
    uint value;
    float distance;
    uint normal;
    vec3 position;
};

vec4 noise_value;
vec2 noise_offset;

#ifdef REPORT_ERROR
bool error = false;
#endif

uint get_step(vec3 tex_pos, uint current_lod) {
    if (current_lod == 0) {
        return texture(minefield, tex_pos).r;
    } else if (current_lod == 1) {
        return texture(minefield_lod1, tex_pos).r;
    }
}

HitResult trace_ray(vec3 origin, vec3 direction) {
    direction = normalize(direction);
    HitResult result;
    result.position = origin;

    // Like a sideways manhattan distance. Basically whichever coordinate is the largest.
    float origin_distance = 0.0;
    origin_distance = max(origin_distance, abs(origin.x));
    origin_distance = max(origin_distance, abs(origin.y));
    origin_distance = max(origin_distance, abs(origin.z));

    // How much to travel along the ray to move 1 unit in a particular axis.
    vec3 length_per_axis = vec3(1) / vec3(abs(direction));
    ivec3 normals = ivec3(
        direction.x > 0 ? NORMAL_x + 1 : NORMAL_x,
        direction.y > 0 ? NORMAL_y + 1 : NORMAL_y,
        direction.z > 0 ? NORMAL_z + 1 : NORMAL_z
    );
    vec3 muls = vec3(
        direction.x > 0 ? -1 : 1,
        direction.y > 0 ? -1 : 1,
        direction.z > 0 ? -1 : 1
    );
    uint current_lod = 0;
    if (origin_distance > ROOT_BLOCK_WIDTH / 2) {
        current_lod = 1;
    }
    uint lod_divisor = (1 << current_lod);
    vec3 pos_offset = vec3(ROOT_BLOCK_WIDTH / 2 * lod_divisor);
    uint current_step = get_step((result.position + pos_offset) / lod_divisor, current_lod);
    uint step_size = (1 << current_step) / 2;

    uint limit = 2048;
    vec3 length_to_next_voxel, lookup_offset;
    // For some reason, using a non-infinite loop boosts performance even though
    // the limit of the loop is never reached.
    for (; limit > 0; limit--) {
        // Things that don't increase performance: 
        // - pre-multiplying result.position 
        // - only setting the result normal if a new value gets hit.
        // - distributing the addition of the offset in any way.
        length_to_next_voxel = (vec3(0.0001) + mod((result.position + pos_offset) * muls, vec3(step_size))) * length_per_axis;
        if (length_to_next_voxel.x < length_to_next_voxel.y) {
            if (length_to_next_voxel.x < length_to_next_voxel.z) { 
                result.position += direction * length_to_next_voxel.x;
                result.normal = normals.x;
            } else {
                result.position += direction * length_to_next_voxel.z;
                result.normal = normals.z;
            }
        } else {
            if (length_to_next_voxel.y < length_to_next_voxel.z) { 
                result.position += direction * length_to_next_voxel.y;
                result.normal = normals.y;
            } else {
                result.position += direction * length_to_next_voxel.z;
                result.normal = normals.z;
            }
        }
        current_step = get_step((result.position + pos_offset) / lod_divisor, current_lod);
        if (current_step <= current_lod) {
            if (
                abs(result.position.x) < ROOT_BLOCK_WIDTH / 2 * lod_divisor
                && abs(result.position.y) < ROOT_BLOCK_WIDTH / 2 * lod_divisor
                && abs(result.position.z) < ROOT_BLOCK_WIDTH / 2 * lod_divisor
            ) {
                // We encountered a block inside the minefield.
                break;
            } else {
                // We encountered the edge of the LOD.
                if (current_lod == 0) {
                    current_lod = 1;
                    lod_divisor *= 2;
                    pos_offset *= 2;
                } else if (current_lod == 1) {
                    // We hit the sky.
                    break;
                }
                // Get the current step, according to the new LOD.
                current_step = get_step((result.position + pos_offset) / lod_divisor, current_lod);
            }
        }
        step_size = (1 << current_step) / 2;
    }

    result.distance = length(origin - result.position);
    if (current_lod == 0) {
        result.value = textureLod(world, (result.position + pos_offset) / vec3(ROOT_BLOCK_WIDTH), 0.0).r;
    } else if (current_lod == 1) {
        if (
            result.position.x > -int(ROOT_BLOCK_WIDTH)
            && result.position.y > -int(ROOT_BLOCK_WIDTH)
            && result.position.z > -int(ROOT_BLOCK_WIDTH)
            && result.position.x < ROOT_BLOCK_WIDTH 
            && result.position.y < ROOT_BLOCK_WIDTH 
            && result.position.z < ROOT_BLOCK_WIDTH
        ) {
            result.value = 2;
        } else {
            result.value = 0;
        }
    }

    float offset_amount = 0.001;

    if (result.normal == NORMAL_x) {
        result.position += vec3(offset_amount, 0, 0);
    } else if (result.normal == NORMAL_x + 1) {
        result.position -= vec3(offset_amount, 0, 0);
    } else if (result.normal == NORMAL_y) {
        result.position += vec3(0, offset_amount, 0);
    } else if (result.normal == NORMAL_y + 1) {
        result.position -= vec3(0, offset_amount, 0);
    } else if (result.normal == NORMAL_z) {
        result.position += vec3(0, 0, offset_amount);
    } else if (result.normal == NORMAL_z + 1) {
        result.position -= vec3(0, 0, offset_amount);
    }

    return result;
}

HitResult trace_sun(HitResult from, vec3 direction) {
    return trace_ray(from.position, normalize(direction + vec3(noise_value.rg, 0) * 0.05));
}

HitResult trace_diffuse(HitResult from) {
    float theta1 = PI * 2.0 * noise_value.r;
    float theta2 = acos(1.0 - 2.0 * noise_value.g);
    // Random point on sphere.
    vec3 direction = vec3(
        sin(theta1) * sin(theta2),
        cos(theta1) * sin(theta2),
        cos(theta2)
    );
    if (from.normal == NORMAL_x) {
        direction += vec3(1, 0, 0);
    } else if (from.normal == NORMAL_x + 1) {
        direction -= vec3(1, 0, 0);
    } else if (from.normal == NORMAL_y) {
        direction += vec3(0, 1, 0);
    } else if (from.normal == NORMAL_y + 1) {
        direction -= vec3(0, 1, 0);
    } else if (from.normal == NORMAL_z) {
        direction += vec3(0, 0, 1);
    } else if (from.normal == NORMAL_z + 1) {
        direction -= vec3(0, 0, 1);
    }
    return trace_ray(from.position, normalize(direction));
}

vec3 debug_normal(uint normal) {
    vec3 color = vec3(1);
    if (normal % 2 == 1) {
        normal -= 1;
        color *= 0.5;
    }
    if (normal == NORMAL_x) {
        color *= vec3(1, 0, 0);
    } else if (normal == NORMAL_y) {
        color *= vec3(0, 1, 0);
    } else if (normal == NORMAL_z) {
        color *= vec3(0, 0, 1);
    }
    return color;
}

vec3 world_space_normal(uint normal) {
    vec3 world_space = vec3(1.0);
    if (normal % 2 == 1) {
        normal -= 1;
        world_space *= -1.0;
    }
    if (normal == NORMAL_x) {
        world_space *= vec3(1, 0, 0);
    } else if (normal == NORMAL_y) {
        world_space *= vec3(0, 1, 0);
    } else if (normal == NORMAL_z) {
        world_space *= vec3(0, 0, 1);
    }
    return world_space;
}

vec3 encode_world_space_normal(uint normal) {
    return world_space_normal(normal) * 0.5 + vec3(0.5);
}

vec2 encode_screen_space_normal(uint normal, vec3 right, vec3 up) {
    vec3 world_space = world_space_normal(normal);
    vec2 screen_space = vec2(
        dot(world_space, right),
        dot(world_space, up)
    );
    return screen_space * 0.5 + vec2(0.5);
}

void main() {
    ivec2 pixel = ivec2(gl_WorkGroupID.xy - gl_WorkGroupID.xy % ivec2(PIXEL_SPREAD));
    pixel *= ivec2(gl_WorkGroupSize.xy);
    pixel += ivec2(gl_WorkGroupID.xy) % ivec2(PIXEL_SPREAD);
    pixel += ivec2(gl_LocalInvocationID.xy * PIXEL_SPREAD);

    vec2 screen_pos = pixel / vec2(imageSize(lighting_buffer));
    screen_pos = screen_pos * 2 - vec2(1);
    vec2 lookup_pos = vec2(
        (uniform_data.seed % NOISE_SIZE),
        (uniform_data.seed / NOISE_SIZE)
    );
    noise_offset.x = texture(blue_noise, lookup_pos).r * 255.0;
    noise_offset.y = texture(blue_noise, lookup_pos).g * 255.0;
    noise_offset += gl_WorkGroupID.xy * gl_WorkGroupSize.xy;

    vec3 ray_start = uniform_data.origin;
    vec3 ray_direction = normalize(
        uniform_data.forward
        + screen_pos.x * uniform_data.right
        + screen_pos.y * uniform_data.up
    );

    float sun_amount = max(cos(uniform_data.sun_angle), 0.0);
    vec3 skylight = vec3(0.5294, 0.8275, 0.9647) * 1.5 * sun_amount + vec3(0.1059, 0.1529, 0.2588) * (1 - sun_amount);
    vec3 sunlight = vec3(1.2059, 1.0784, 0.9137) * sun_amount + vec3(0.9255, 0.3333, 0.1843) * (1 - sun_amount);
    sunlight *= min(sun_amount * 6.0, 1.0);
    vec3 sunangle = vec3(cos(uniform_data.sun_angle) * 0.5, sin(uniform_data.sun_angle), cos(uniform_data.sun_angle));
    vec3 light = skylight;
    HitResult primary = trace_ray(uniform_data.origin, ray_direction);
    if (primary.value > 0) {
        light = vec3(0.0);
        noise_value = texture(blue_noise, mod(noise_offset, vec2(NOISE_SIZE)));
        HitResult sun1 = trace_sun(primary, sunangle);
        if (sun1.value == 0) {
            light += sunlight;
        }
        HitResult dif1 = trace_diffuse(primary);
        if (dif1.value == 0) {
            light += skylight;
        } else {
            vec3 light2 = vec3(0.0);
            vec3 albedo2 = get_material_albedo(dif1.value);
            noise_value = texture(blue_noise, mod(noise_offset + vec2(2.0 / NOISE_SIZE), vec2(NOISE_SIZE)));
            HitResult sun2 = trace_sun(dif1, sunangle);
            if (sun2.value == 0 && false) {
                light2 += albedo2 * sunlight;
            }
            HitResult dif2 = trace_diffuse(dif1);
            if (dif2.value == 0 && false) {
                light2 += albedo2 * skylight;
            }
            light2 += get_material_emission(dif1.value);
            light += light2;
        }
    }

    imageStore(
      lighting_buffer,
      pixel,
      vec4(light, 1.0) / LIGHTING_SCALE
    );
    imageStore(
        depth_buffer,
        pixel,
        uvec4(length(uniform_data.origin - primary.position) * 64)
    );
    imageStore(
        normal_buffer,
        pixel,
        uvec4(primary.value == 0 ? 16 : primary.normal)
    );
    imageStore(
        albedo_buffer,
        pixel,
        primary.value == 0 ? vec4(1.0) : vec4(get_material_albedo(primary.value), 1.0)
    );
    imageStore(
        emission_buffer,
        pixel,
        primary.value == 0 ? vec4(0.0) : vec4(get_material_emission(primary.value) / 4.0, 1.0)
    );
    imageStore(
        fog_color_buffer,
        pixel,
        vec4(skylight / vec3(LIGHTING_SCALE), 1.0)
    );

    #ifdef REPORT_ERROR
    if (error) {
        imageStore(
            fog_color_buffer,
            pixel,
            vec4(1, 0, 1, 1)
        );
        imageStore(
            depth_buffer,
            pixel,
            uvec4(256 * 254)
        );
    }
    #endif
}