#version 450

// If defined, a limiter will be applied to terminate any ray trace that takes too long. The pixel
// the ray trace occured for will be highlighted in pink.
// #define REPORT_ERROR

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform usampler3D world;

layout(set = 0, binding = 1, rgba16) uniform writeonly image2D lighting_buffer;
layout(set = 0, binding = 2, rgba8) uniform writeonly image2D albedo_buffer;
layout(set = 0, binding = 3, rgba8) uniform writeonly image2D emission_buffer;
layout(set = 0, binding = 4, rgba8) uniform writeonly image2D fog_color_buffer;
layout(set = 0, binding = 5, r8ui) uniform writeonly uimage2D normal_buffer;
layout(set = 0, binding = 6, r16ui) uniform writeonly uimage2D depth_buffer;

layout(set = 0, binding = 7, rgba16) uniform readonly image2D old_lighting_buffer;
layout(set = 0, binding = 8, r16ui) uniform readonly uimage2D old_depth_buffer;
layout(set = 0, binding = 9, r8ui) uniform readonly uimage2D old_normal_buffer;

layout(set = 0, binding = 10) uniform sampler2D blue_noise;
layout(set = 0, binding = 11) uniform UniformData {
    float sun_angle;
    uint seed;
    vec3 origin, forward, up, right;
    // For some reason doing mat3 still loads 16 elements but the rust bindings give it 9, making
    // the whole thing go out of order. So transmit each individual column instead.
    vec3 old_origin, old_transform_c0, old_transform_c1, old_transform_c2;
    ivec3 region_offset;
} uniform_data;

const uint CHUNK_BLOCK_WIDTH = 8;
const uint CHUNK_BLOCK_VOLUME = CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint REGION_CHUNK_WIDTH = 8;
const uint REGION_BLOCK_WIDTH = REGION_CHUNK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint ROOT_REGION_WIDTH = 8;
const uint ROOT_REGION_VOLUME = ROOT_REGION_WIDTH * ROOT_REGION_WIDTH * ROOT_REGION_WIDTH;
const uint ROOT_CHUNK_WIDTH = ROOT_REGION_WIDTH * REGION_CHUNK_WIDTH;
const uint ROOT_CHUNK_VOLUME = ROOT_CHUNK_WIDTH * ROOT_CHUNK_WIDTH * ROOT_CHUNK_WIDTH;
const uint ROOT_BLOCK_WIDTH = ROOT_CHUNK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint ATLAS_CHUNK_WIDTH = 64; 
const uint ATLAS_BLOCK_WIDTH = ATLAS_CHUNK_WIDTH * CHUNK_BLOCK_WIDTH;
const uint ATLAS_CHUNK_VOLUME = ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH;

const uint EMPTY_CHUNK_INDEX = 0xFFFF;
const uint UNLOADED_CHUNK_INDEX = 0xFFFE;
const uint REQUEST_LOAD_CHUNK_INDEX = 0xFFFD;

const uint NOISE_SIZE = 512;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;

const float PI = 3.1415926535897932384626433832795;

struct HitResult {
    uint value;
    float distance;
    uint normal;
    vec3 position;
};

vec4 noise_value;
vec2 noise_offset;

#ifdef REPORT_ERROR
bool error = false;
#endif

HitResult result;
vec3 length_per_axis;
ivec3 normals;
vec3 muls;
vec3 length_to_next_voxel;
int limit;
HitResult trace_ray(vec3 origin, vec3 direction) {
    direction = normalize(direction);

    result;
    result.value = 0;
    result.position = origin;
    // How much to travel along the ray to move 1 unit in a particular axis.
    length_per_axis = vec3(1) / vec3(abs(direction));
    normals = ivec3(
        direction.x > 0 ? NORMAL_x + 1 : NORMAL_x,
        direction.y > 0 ? NORMAL_y + 1 : NORMAL_y,
        direction.z > 0 ? NORMAL_z + 1 : NORMAL_z
    );
    muls = vec3(
        direction.x > 0 ? -1 : 1,
        direction.y > 0 ? -1 : 1,
        direction.z > 0 ? -1 : 1
    );
    length_to_next_voxel;

    limit = 2048;
    // For some reason, using a non-infinite loop boosts performance.
    for (; result.value == 0 && limit > 0; limit--) {
        // Things that don't increase performance: 
        // - pre-multiplying result.position 
        // - scaling result.position to have 1.0 be the end coordinate of the world.
        // - only setting the result normal if a new value gets hit.
        // - distributing the addition of the offset in any way.
        length_to_next_voxel = (vec3(0.001) + mod(result.position * muls, vec3(1.0))) * length_per_axis;
        if (length_to_next_voxel.x < length_to_next_voxel.y) {
            if (length_to_next_voxel.x < length_to_next_voxel.z) { 
                result.position += direction * length_to_next_voxel.x;
                result.normal = normals.x;
            } else {
                result.position += direction * length_to_next_voxel.z;
                result.normal = normals.z;
            }
        } else {
            if (length_to_next_voxel.y < length_to_next_voxel.z) { 
                result.position += direction * length_to_next_voxel.y;
                result.normal = normals.y;
            } else {
                result.position += direction * length_to_next_voxel.z;
                result.normal = normals.z;
            }
        }
        result.value = textureLod(world, result.position / vec3(ROOT_BLOCK_WIDTH), 0.0).r;
    }

    if (result.value == 1) {
        result.value = 0;
    }

    result.distance = length(origin - result.position);

    if (result.normal == NORMAL_x) {
        result.position += vec3(0.002, 0, 0);
    } else if (result.normal == NORMAL_x + 1) {
        result.position -= vec3(0.002, 0, 0);
    } else if (result.normal == NORMAL_y) {
        result.position += vec3(0, 0.002, 0);
    } else if (result.normal == NORMAL_y + 1) {
        result.position -= vec3(0, 0.002, 0);
    } else if (result.normal == NORMAL_z) {
        result.position += vec3(0, 0, 0.002);
    } else if (result.normal == NORMAL_z + 1) {
        result.position -= vec3(0, 0, 0.002);
    }

    return result;
}

HitResult trace_sun(HitResult from, vec3 direction) {
    return trace_ray(from.position, normalize(direction + vec3(noise_value.rg, 0) * 0.05));
}

HitResult trace_diffuse(HitResult from) {
    float theta1 = PI * 2.0 * noise_value.r;
    float theta2 = acos(1.0 - 2.0 * noise_value.g);
    // Random point on sphere.
    vec3 direction = vec3(
        sin(theta1) * sin(theta2),
        cos(theta1) * sin(theta2),
        cos(theta2)
    );
    if (from.normal == NORMAL_x) {
        direction += vec3(1, 0, 0);
    } else if (from.normal == NORMAL_x + 1) {
        direction -= vec3(1, 0, 0);
    } else if (from.normal == NORMAL_y) {
        direction += vec3(0, 1, 0);
    } else if (from.normal == NORMAL_y + 1) {
        direction -= vec3(0, 1, 0);
    } else if (from.normal == NORMAL_z) {
        direction += vec3(0, 0, 1);
    } else if (from.normal == NORMAL_z + 1) {
        direction -= vec3(0, 0, 1);
    }
    return trace_ray(from.position, normalize(direction));
}

vec3 get_material_albedo(uint material) {
    switch (material) {
        case 0:
        return vec3(1, 0, 1);
        case 1:
        return vec3(1, 0, 1);
        case 2:
        return vec3(0.3098, 0.8667, 0.4784);
        case 3:
        return vec3(0.4, 0.3, 0.2);
        case 4:
        return vec3(0.4);
        case 5:
        return vec3(0.4863, 0.2118, 0.1725);
        case 6:
        return vec3(0.8667, 0.9137, 0.9059);
        case 7:
        return vec3(0.9, 0.7, 0.2);
        case 8:
        return vec3(0.8, 0.2, 0.7);
        case 9:
        return vec3(0.2, 0.2, 0.2);
    }
}

vec3 get_material_emission(uint material) {
    switch (material) {
        case 0:
        return vec3(0);
        case 1:
        return vec3(0);
        case 2:
        return vec3(0);
        case 3:
        return vec3(2.5, 1.2, 0.6);
        case 4:
        return vec3(0);
        case 5:
        return vec3(0);
        case 6:
        return vec3(0);
        case 7:
        return vec3(0);
        case 8:
        return vec3(0);
        case 9:
        return vec3(0);
    }
}

vec3 debug_normal(uint normal) {
    vec3 color = vec3(1);
    if (normal % 2 == 1) {
        normal -= 1;
        color *= 0.5;
    }
    if (normal == NORMAL_x) {
        color *= vec3(1, 0, 0);
    } else if (normal == NORMAL_y) {
        color *= vec3(0, 1, 0);
    } else if (normal == NORMAL_z) {
        color *= vec3(0, 0, 1);
    }
    return color;
}

vec3 world_space_normal(uint normal) {
    vec3 world_space = vec3(1.0);
    if (normal % 2 == 1) {
        normal -= 1;
        world_space *= -1.0;
    }
    if (normal == NORMAL_x) {
        world_space *= vec3(1, 0, 0);
    } else if (normal == NORMAL_y) {
        world_space *= vec3(0, 1, 0);
    } else if (normal == NORMAL_z) {
        world_space *= vec3(0, 0, 1);
    }
    return world_space;
}

vec3 encode_world_space_normal(uint normal) {
    return world_space_normal(normal) * 0.5 + vec3(0.5);
}

vec2 encode_screen_space_normal(uint normal, vec3 right, vec3 up) {
    vec3 world_space = world_space_normal(normal);
    vec2 screen_space = vec2(
        dot(world_space, right),
        dot(world_space, up)
    );
    return screen_space * 0.5 + vec2(0.5);
}

void main() {
    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(imageSize(lighting_buffer));
    screen_pos = screen_pos * 2 - vec2(1);
    vec2 lookup_pos = vec2(
        (uniform_data.seed % NOISE_SIZE),
        (uniform_data.seed / NOISE_SIZE)
    );
    noise_offset.x = texture(blue_noise, lookup_pos).r * 255.0;
    noise_offset.y = texture(blue_noise, lookup_pos).g * 255.0;
    noise_offset += gl_GlobalInvocationID.xy;

    vec3 ray_start = uniform_data.origin;
    vec3 ray_direction = normalize(
        uniform_data.forward
        + screen_pos.x * uniform_data.right
        + screen_pos.y * uniform_data.up
    );

    float sun_amount = max(cos(uniform_data.sun_angle), 0.0);
    vec3 skylight = vec3(0.5294, 0.8275, 0.9647) * 1.3 * sun_amount + vec3(0.1059, 0.1529, 0.2588) * (1 - sun_amount);
    vec3 sunlight = vec3(1.2059, 1.0784, 0.9137) * sun_amount + vec3(0.9255, 0.3333, 0.1843) * (1 - sun_amount);
    sunlight *= min(sun_amount * 9.0, 1.0);
    vec3 sunangle = vec3(cos(uniform_data.sun_angle) * 0.5, sin(uniform_data.sun_angle), cos(uniform_data.sun_angle));
    vec3 light = skylight;
    HitResult primary = trace_ray(uniform_data.origin, ray_direction);
    if (primary.value > 0) {
        light = vec3(0.0);
        noise_value = texture(blue_noise, mod(noise_offset, vec2(NOISE_SIZE)));
        HitResult sun1 = trace_sun(primary, sunangle);
        if (sun1.value == 0) {
            light += sunlight;
        }
        HitResult dif1 = trace_diffuse(primary);
        if (dif1.value == 0) {
            light += skylight;
        } else {
            vec3 light2 = vec3(0.0);
            vec3 albedo2 = get_material_albedo(dif1.value);
            noise_value = texture(blue_noise, mod(noise_offset + vec2(2.0 / NOISE_SIZE), vec2(NOISE_SIZE)));
            HitResult sun2 = trace_sun(dif1, sunangle);
            if (sun2.value == 0 && false) {
                light2 += albedo2 * sunlight;
            }
            HitResult dif2 = trace_diffuse(dif1);
            if (dif2.value == 0 && false) {
                light2 += albedo2 * skylight;
            }
            light2 += get_material_emission(dif1.value);
            light += light2;
        }
    }

    vec4 pixel_value = vec4(light, 1.0 / 126.0);

    vec3 old_camera_pos = primary.position - uniform_data.old_origin;
    mat3 old_screen_space_transform = mat3(
        uniform_data.old_transform_c0, 
        uniform_data.old_transform_c1, 
        uniform_data.old_transform_c2
    );
    uint expected_depth = uint(length(old_camera_pos) * 64);
    vec3 old_screen_pos = old_screen_space_transform * old_camera_pos;
    old_screen_pos.x /= old_screen_pos.z;
    old_screen_pos.y /= old_screen_pos.z;
    ivec2 lighting_buffer_size = imageSize(lighting_buffer);
    ivec2 old_screen_pixel_pos = ivec2((old_screen_pos.xy + 1.0) * 0.5 * lighting_buffer_size + vec2(0.5));
    if (
        old_screen_pixel_pos.x >= 0 && 
        old_screen_pixel_pos.y >= 0 && 
        old_screen_pixel_pos.x < lighting_buffer_size.x && 
        old_screen_pixel_pos.y < lighting_buffer_size.y
    ) {
        uint old_depth = imageLoad(old_depth_buffer, old_screen_pixel_pos).r;
        uint depth_difference = (old_depth > expected_depth ? old_depth - expected_depth : expected_depth - old_depth);
        uint old_normal = imageLoad(old_normal_buffer, old_screen_pixel_pos).r;
        if (depth_difference < 32 && old_normal == primary.normal) {
            vec4 old_pixel = imageLoad(old_lighting_buffer, old_screen_pixel_pos) * 4.0;
            float new_weight = old_pixel.a;
            if (new_weight < 0.1) {
                new_weight += 1.0 / 126.0;
            }
            float old_weight = (new_weight - 1.0 / 126.0) / new_weight;
            pixel_value = vec4(old_pixel.rgb * old_weight + pixel_value.xyz * (1.0 - old_weight), new_weight);
        }
    }

    imageStore(
      lighting_buffer,
      ivec2(gl_GlobalInvocationID.xy), 
      vec4(pixel_value) / 4.0
    );
    imageStore(
        depth_buffer,
        ivec2(gl_GlobalInvocationID.xy),
        uvec4(length(uniform_data.origin - primary.position) * 64)
    );
    imageStore(
        normal_buffer,
        ivec2(gl_GlobalInvocationID.xy),
        uvec4(primary.value == 0 ? 16 : primary.normal)
    );
    imageStore(
        albedo_buffer,
        ivec2(gl_GlobalInvocationID.xy),
        primary.value == 0 ? vec4(1.0) : vec4(get_material_albedo(primary.value), 1.0)
    );
    imageStore(
        emission_buffer,
        ivec2(gl_GlobalInvocationID.xy),
        primary.value == 0 ? vec4(0.0) : vec4(get_material_emission(primary.value) / 4.0, 1.0)
    );
    imageStore(
      fog_color_buffer,
      ivec2(gl_GlobalInvocationID.xy), 
      vec4(skylight, 1.0)
    );
    #ifdef REPORT_ERROR
    if (error) {
        imageStore(
            fog_color_buffer,
            ivec2(gl_GlobalInvocationID.xy), 
            vec4(1, 0, 1, 1)
        );
        imageStore(
            depth_buffer,
            ivec2(gl_GlobalInvocationID.xy),
            uvec4(256 * 254)
        );
    }
    #endif
}