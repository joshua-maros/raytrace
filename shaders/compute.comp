#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r32ui) uniform uimage3D in_data;
layout(set = 0, binding = 1, rgba8) uniform writeonly image2D img;

const float IMAGE_WIDTH = 512.0;
const float IMAGE_HEIGHT = 512.0;

void main() {
    vec3 ray_start = vec3(
        gl_GlobalInvocationID.x / 16.0 + 16.51,
        0.5,
        gl_GlobalInvocationID.y / 16.0 + 16.51
    );
    ivec3 current_voxel = ivec3(
        floor(ray_start.x),
        floor(ray_start.y),
        floor(ray_start.z)
    );

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(IMAGE_WIDTH, IMAGE_HEIGHT);
    // Must be normalized. 
    vec3 ray_direction = normalize(vec3(
        screen_pos.x * 0.6 - 0.3,
        1.0,
        screen_pos.y * 0.6 - 0.3
    ));

    ivec3 ray_step = ivec3(
        ray_direction.x < 0 ? -1 : 1,
        ray_direction.y < 0 ? -1 : 1,
        ray_direction.z < 0 ? -1 : 1
    );
    // How much we need to move along the vector to reach the next voxel in the
    // x, y, and z directions.
    vec3 min_step_to_boundary = vec3(0);
    if (ray_step.x == 1) {
        min_step_to_boundary.x = (1.0 - mod(ray_start.x, 1.0)) / (ray_direction.x + 1e-8);
    } else {
        min_step_to_boundary.x = mod(ray_start.x, 1.0) / (-ray_direction.x + 1e-8);
    }
    if (ray_step.y == 1) {
        min_step_to_boundary.y = (1.0 - mod(ray_start.y, 1.0)) / (ray_direction.y + 1e-8);
    } else {
        min_step_to_boundary.y = mod(ray_start.y, 1.0) / (-ray_direction.y + 1e-8);
    }
    if (ray_step.z == 1) {
        min_step_to_boundary.z = (1.0 - mod(ray_start.z, 1.0)) / (ray_direction.z + 1e-8);
    } else {
        min_step_to_boundary.z = mod(ray_start.z, 1.0) / (-ray_direction.z + 1e-8);
    }
    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 voxel_width_step_size = abs(vec3(
        1.0 / (ray_direction.x + 1e-8),
        1.0 / (ray_direction.y + 1e-8),
        1.0 / (ray_direction.z + 1e-8)
    ));
    // Sky color.
    vec4 color = vec4(0.5765, 0.6196, 0.8549, 1.0);
    while (true) {
        if (imageLoad(in_data, current_voxel).r > 0) {
            color.rgb = current_voxel / 90.0 + 0.3 * mod(current_voxel, vec3(2));
            break;
        }

        if (min_step_to_boundary.x < min_step_to_boundary.y) {
            if (min_step_to_boundary.x < min_step_to_boundary.z) {
                current_voxel.x += ray_step.x;
                if (current_voxel.x > 64 || current_voxel.x < 0) {
                    break;
                }
                min_step_to_boundary.x += voxel_width_step_size.x;
            } else {
                current_voxel.z += ray_step.z;
                if (current_voxel.z > 64 || current_voxel.z < 0) {
                    break;
                }
                min_step_to_boundary.z += voxel_width_step_size.z;
            }
        } else {
            if (min_step_to_boundary.y < min_step_to_boundary.z) {
                current_voxel.y += ray_step.y;
                if (current_voxel.y > 64 || current_voxel.y < 0) {
                    break;
                }
                min_step_to_boundary.y += voxel_width_step_size.y;
            } else {
                current_voxel.z += ray_step.z;
                if (current_voxel.z > 64 || current_voxel.z < 0) {
                    break;
                }
                min_step_to_boundary.z += voxel_width_step_size.z;
            }
        }
    }
    imageStore(img, ivec2(gl_GlobalInvocationID.xy), color);
}