#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r32ui) uniform uimage3D l1;
layout(set = 0, binding = 1, r32ui) uniform uimage3D l2;
layout(set = 0, binding = 2, rgba8) uniform writeonly image2D img;

layout(push_constant) uniform CameraVectors {
    vec3 origin, forward, up, right;
} camera_vectors;

const float IMAGE_WIDTH = 512.0;
const float IMAGE_HEIGHT = 512.0;
const uint WORLD_SIZE = 256;
const uint L2_STEP = 16;
const float L2_STEPF = L2_STEP;
const uint L2_SIZE = WORLD_SIZE / L2_STEP;

const uint MODE_L1 = 0;
const uint MODE_L2 = 1;

struct HitResult {
    uint value;
    vec3 position;
};

#define PERFORM_L1_STEP(AXIS) \
    l1_pos. AXIS += l1_step. AXIS ; \
    if (l1_pos. AXIS == l1_exit_planes. AXIS) { break; } \
    total_step = l1_to_boundary. AXIS ; \
    result.value = imageLoad(l1, l1_pos).r; \
    if (result.value != 0) { break; } \
    l1_to_boundary. AXIS += l1_advance_amount. AXIS ;

#define PERFORM_L1_TRACE() \
        ivec3 l1_exit_planes = ivec3( \
            l2_pos.x * L2_STEP + (l1_step.x == 1 ? L2_STEP : - 1), \
            l2_pos.y * L2_STEP + (l1_step.y == 1 ? L2_STEP : - 1), \
            l2_pos.z * L2_STEP + (l1_step.z == 1 ? L2_STEP : - 1) \
        ); \
        vec3 exact_pos = origin + direction * (total_step + 0.01); \
        ivec3 l1_pos = ivec3( \
            floor(exact_pos.x), \
            floor(exact_pos.y), \
            floor(exact_pos.z) \
        ); \
        \
        vec3 l1_to_boundary = vec3(0); \
        if (l1_step.x == 1) { \
            l1_to_boundary.x =  \
                (1.0 - mod(exact_pos.x, 1.0))  \
                * l1_advance_amount.x; \
        } else { \
            l1_to_boundary.x =  \
                mod(exact_pos.x, 1.0) * l1_advance_amount.x; \
        } \
        if (l1_step.y == 1) { \
            l1_to_boundary.y =  \
                (1.0 - mod(exact_pos.y, 1.0))  \
                * l1_advance_amount.y; \
        } else { \
            l1_to_boundary.y =  \
                mod(exact_pos.y, 1.0) * l1_advance_amount.y; \
        } \
        if (l1_step.z == 1) { \
            l1_to_boundary.z =  \
                (1.0 - mod(exact_pos.z, 1.0))  \
                * l1_advance_amount.z; \
        } else { \
            l1_to_boundary.z =  \
                mod(exact_pos.z, 1.0) * l1_advance_amount.z; \
        } \
        l1_to_boundary += vec3(total_step); \
        \
        result.value = imageLoad(l1, l1_pos).r; \
        if (result.value == 0) { while (true) { \
            if (l1_to_boundary.x < l1_to_boundary.y) { \
                if (l1_to_boundary.x < l1_to_boundary.z) { \
                    PERFORM_L1_STEP(x); \
                } else { \
                    PERFORM_L1_STEP(z); \
                } \
            } else { \
                if (l1_to_boundary.y < l1_to_boundary.z) { \
                    PERFORM_L1_STEP(y); \
                } else { \
                    PERFORM_L1_STEP(z); \
                } \
            } \
        } }

#define PERFORM_L2_STEP(AXIS) \
    l2_pos. AXIS += l1_step. AXIS ; \
    total_step = l2_to_boundary. AXIS ; \
    if (l2_pos. AXIS > L2_SIZE || l2_pos. AXIS < 0) { break; } \
    result.value = imageLoad(l2, l2_pos).r; \
    if (result.value != 0) { \
        PERFORM_L1_TRACE(); \
        if (result.value != 0) { break; } \
    } \
    l2_to_boundary. AXIS += l2_advance_amount. AXIS ;

HitResult trace_ray(vec3 origin, vec3 direction) {
    ivec3 l2_pos = ivec3(
        floor(origin.x),
        floor(origin.y),
        floor(origin.z)
    ) / ivec3(L2_STEP);
    ivec3 l1_step = ivec3(
        direction.x < 0 ? -1 : 1,
        direction.y < 0 ? -1 : 1,
        direction.z < 0 ? -1 : 1
    );
    ivec3 l2_step = l1_step * ivec3(L2_STEP);

    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 l1_advance_amount = abs(vec3(
        1.0 / (direction.x + 1e-8),
        1.0 / (direction.y + 1e-8),
        1.0 / (direction.z + 1e-8)
    ));
    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* L2_STEPF in the x, y, and z directions. 
    vec3 l2_advance_amount = l1_advance_amount * vec3(L2_STEPF);
    // How much we need to move along the vector to reach the next voxel in the
    // x, y, and z directions. In this case, since it is l2, 'voxel' refers to
    // an 8x8x8 segment.

    vec3 l2_to_boundary = vec3(0);
    if (l1_step.x == 1) {
        l2_to_boundary.x = (L2_STEPF - mod(origin.x, L2_STEPF)) * l1_advance_amount.x;
    } else {
        l2_to_boundary.x = mod(origin.x, L2_STEPF) * l1_advance_amount.x;
    }
    if (l1_step.y == 1) {
        l2_to_boundary.y = (L2_STEPF - mod(origin.y, L2_STEPF)) * l1_advance_amount.y;
    } else {
        l2_to_boundary.y = mod(origin.y, L2_STEPF) * l1_advance_amount.y;
    }
    if (l1_step.z == 1) {
        l2_to_boundary.z = (L2_STEPF - mod(origin.z, L2_STEPF)) * l1_advance_amount.z;
    } else {
        l2_to_boundary.z = mod(origin.z, L2_STEPF) * l1_advance_amount.z;
    }

    HitResult result;
    float total_step = 0.0;
    uint mode = MODE_L1;
    result.value = imageLoad(l2, l2_pos).r;
    if (result.value != 0) {
        PERFORM_L1_TRACE();
    }
    if (result.value == 0) { while (true) {
        if (l2_to_boundary.x < l2_to_boundary.y) {
            if (l2_to_boundary.x < l2_to_boundary.z) {
                PERFORM_L2_STEP(x);
            } else {
                PERFORM_L2_STEP(z);
            }
        } else {
            if (l2_to_boundary.y < l2_to_boundary.z) {
                PERFORM_L2_STEP(y);
            } else {
                PERFORM_L2_STEP(z);
            }
        }
    } }
    result.position = origin + direction * (total_step - 0.01);
    return result;
}

void main() {
    vec3 ray_start = camera_vectors.origin;
    // Angle pointing from the groud to the sun.
    vec3 sun_directions[5] = vec3[5](
        -normalize(vec3(0.5, 0.5, -1)),
        -normalize(vec3(0.4, 0.5, -1)),
        -normalize(vec3(0.6, 0.5, -1)),
        -normalize(vec3(0.5, 0.4, -1)),
        -normalize(vec3(0.5, 0.6, -1))
    );

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(IMAGE_WIDTH, IMAGE_HEIGHT) * 2.0 - vec2(1);
    // Must be normalized. 
    vec3 ray_direction = normalize(
        camera_vectors.forward
        + screen_pos.x * camera_vectors.right
        + screen_pos.y * camera_vectors.up
    );

    // Sky color.
    vec4 color = vec4(0.5765, 0.6196, 0.8549, 1.0);
    HitResult result = trace_ray(camera_vectors.origin, ray_direction);
    if (result.value > 0) {
        color.rgb = result.position / (WORLD_SIZE / 1.0);
        int shadow = 0;
        for (int i = 0; i < 5; i++) {
            HitResult sun = trace_ray(result.position, sun_directions[i]);
            if (sun.value > 0) {
                shadow += 1;
            }
        }
        color.rgb *= (1.0 - shadow * 0.1);
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), color);
}