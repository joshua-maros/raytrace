#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r16ui) uniform uimage3D l1;
layout(set = 0, binding = 1, r16ui) uniform uimage3D l2;
layout(set = 0, binding = 2, rgba16ui) uniform writeonly uimage2D position_out;
layout(set = 0, binding = 3, r16ui) uniform writeonly uimage2D hit_result_out;
layout(set = 0, binding = 4, r32ui) uniform uimage3D lightmap_requirement_out;
layout(set = 0, binding = 5, r32ui) uniform uimage1D total_required_lightmaps;

layout(push_constant) uniform CameraVectors {
    vec3 origin, forward, up, right;
} camera_vectors;

const uint WORLD_SIZE = 256;
const uint L2_STEP = 16;
const float L2_STEPF = L2_STEP;
const uint L2_SIZE = WORLD_SIZE / L2_STEP;

const uint MODE_L1 = 0;
const uint MODE_L2 = 1;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;
const uint POSITION_PRECISION = 64; // How much to scale hit result position by.

struct HitResult {
    uint value;
    vec3 position;
    float distance;
    uint normal;
};

#define PERFORM_L1_STEP(AXIS) \
    l1_pos. AXIS += l1_step. AXIS ; \
    if (l1_pos. AXIS == l1_exit_planes. AXIS) { break; } \
    total_step = l1_to_boundary. AXIS ; \
    result.value = imageLoad(l1, l1_pos).r; \
    if (result.value != 0) { \
        result.normal = NORMAL_##AXIS + (l1_step.AXIS) / 2; \
        break; \
    } \
    l1_to_boundary. AXIS += l1_advance_amount. AXIS ;

#define PERFORM_L1_TRACE(AXIS) \
        ivec3 l1_exit_planes = ivec3( \
            l2_pos.x * L2_STEP + (l1_step.x == 1 ? L2_STEP : - 1), \
            l2_pos.y * L2_STEP + (l1_step.y == 1 ? L2_STEP : - 1), \
            l2_pos.z * L2_STEP + (l1_step.z == 1 ? L2_STEP : - 1) \
        ); \
        vec3 exact_pos = origin + direction * (total_step + 0.01); \
        l1_pos = ivec3( \
            floor(exact_pos.x), \
            floor(exact_pos.y), \
            floor(exact_pos.z) \
        ); \
        \
        vec3 l1_to_boundary = vec3(0); \
        if (l1_step.x == 1) { \
            l1_to_boundary.x =  \
                (1.0 - mod(exact_pos.x, 1.0))  \
                * l1_advance_amount.x; \
        } else { \
            l1_to_boundary.x =  \
                mod(exact_pos.x, 1.0) * l1_advance_amount.x; \
        } \
        if (l1_step.y == 1) { \
            l1_to_boundary.y =  \
                (1.0 - mod(exact_pos.y, 1.0))  \
                * l1_advance_amount.y; \
        } else { \
            l1_to_boundary.y =  \
                mod(exact_pos.y, 1.0) * l1_advance_amount.y; \
        } \
        if (l1_step.z == 1) { \
            l1_to_boundary.z =  \
                (1.0 - mod(exact_pos.z, 1.0))  \
                * l1_advance_amount.z; \
        } else { \
            l1_to_boundary.z =  \
                mod(exact_pos.z, 1.0) * l1_advance_amount.z; \
        } \
        l1_to_boundary += vec3(total_step); \
        \
        result.value = imageLoad(l1, l1_pos).r; \
        if (result.value == 0) { while (true) { \
            if (l1_to_boundary.x < l1_to_boundary.y) { \
                if (l1_to_boundary.x < l1_to_boundary.z) { \
                    PERFORM_L1_STEP(x); \
                } else { \
                    PERFORM_L1_STEP(z); \
                } \
            } else { \
                if (l1_to_boundary.y < l1_to_boundary.z) { \
                    PERFORM_L1_STEP(y); \
                } else { \
                    PERFORM_L1_STEP(z); \
                } \
            } \
        } } else { \
            result.normal = NORMAL_##AXIS + (l1_step.AXIS) / 2; \
        }

#define PERFORM_L2_STEP(AXIS) \
    l2_pos. AXIS += l1_step. AXIS ; \
    if (l2_pos. AXIS > L2_SIZE || l2_pos. AXIS < 0) { break; } \
    result.value = imageLoad(l2, l2_pos).r; \
    if (result.value != 0) { \
        PERFORM_L1_TRACE(AXIS); \
        if (result.value != 0) { break; } \
    } \
    l2_to_boundary. AXIS += l2_advance_amount. AXIS ;

HitResult trace_ray(vec3 origin, vec3 direction) {
    ivec3 l1_pos = ivec3(0);
    ivec3 l2_pos = ivec3(
        floor(origin.x),
        floor(origin.y),
        floor(origin.z)
    ) / ivec3(L2_STEP);
    ivec3 l1_step = ivec3(
        direction.x < 0 ? -1 : 1,
        direction.y < 0 ? -1 : 1,
        direction.z < 0 ? -1 : 1
    );
    ivec3 l2_step = l1_step * ivec3(L2_STEP);

    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 l1_advance_amount = abs(vec3(
        1.0 / (direction.x + 1e-8),
        1.0 / (direction.y + 1e-8),
        1.0 / (direction.z + 1e-8)
    ));
    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* L2_STEPF in the x, y, and z directions. 
    vec3 l2_advance_amount = l1_advance_amount * vec3(L2_STEPF);
    // How much we need to move along the vector to reach the next voxel in the
    // x, y, and z directions. In this case, since it is l2, 'voxel' refers to
    // an 8x8x8 segment.

    vec3 l2_to_boundary = vec3(0);
    if (l1_step.x == 1) {
        l2_to_boundary.x = (L2_STEPF - mod(origin.x, L2_STEPF)) * l1_advance_amount.x;
    } else {
        l2_to_boundary.x = mod(origin.x, L2_STEPF) * l1_advance_amount.x;
    }
    if (l1_step.y == 1) {
        l2_to_boundary.y = (L2_STEPF - mod(origin.y, L2_STEPF)) * l1_advance_amount.y;
    } else {
        l2_to_boundary.y = mod(origin.y, L2_STEPF) * l1_advance_amount.y;
    }
    if (l1_step.z == 1) {
        l2_to_boundary.z = (L2_STEPF - mod(origin.z, L2_STEPF)) * l1_advance_amount.z;
    } else {
        l2_to_boundary.z = mod(origin.z, L2_STEPF) * l1_advance_amount.z;
    }

    HitResult result;
    float total_step = 0.0;
    uint mode = MODE_L1;
    result.value = imageLoad(l2, l2_pos).r;
    if (result.value != 0) {
        PERFORM_L1_TRACE(x);
    }
    if (result.value == 0) { while (true) {
        if (l2_to_boundary.x < l2_to_boundary.y) {
            if (l2_to_boundary.x < l2_to_boundary.z) {
                PERFORM_L2_STEP(x);
            } else {
                PERFORM_L2_STEP(z);
            }
        } else {
            if (l2_to_boundary.y < l2_to_boundary.z) {
                PERFORM_L2_STEP(y);
            } else {
                PERFORM_L2_STEP(z);
            }
        }
    } }
    result.distance = total_step;
    result.position = origin + direction * result.distance;
    if (result.value != 0) {
        uint lightmap_level = 0;
        if (result.distance > /*5*/0) {
            lightmap_level++;
        }
        if (result.distance > /*10*/0) {
            lightmap_level++;
        }
        uint old_value = imageAtomicMin(lightmap_requirement_out, l2_pos, lightmap_level);
        if (old_value > lightmap_level) {
            imageAtomicAdd(total_required_lightmaps, int(old_value), uint(-1));
            imageAtomicAdd(total_required_lightmaps, int(lightmap_level), 1);
        }
    }
    return result;
}

void main() {
    vec3 ray_start = camera_vectors.origin;

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(imageSize(position_out)) * 2.0 - vec2(1);
    // Must be normalized. 
    vec3 ray_direction = normalize(
        camera_vectors.forward
        + screen_pos.x * camera_vectors.right
        + screen_pos.y * camera_vectors.up
    );

    HitResult result = trace_ray(camera_vectors.origin, ray_direction);

    imageStore(
        position_out, 
        ivec2(gl_GlobalInvocationID.xy), 
        ivec4(result.position * POSITION_PRECISION, result.distance * POSITION_PRECISION)
    );
    imageStore(
        hit_result_out, 
        ivec2(gl_GlobalInvocationID.xy), 
        ivec4(result.value | result.normal << 12)
    );
}