#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r16ui) uniform uimage3D block_data_atlas;
layout(set = 0, binding = 1, r16ui) uniform uimage3D piece_mip_atlas;
layout(set = 0, binding = 2, r16ui) uniform uimage3D root;
layout(set = 0, binding = 3, rgba8_snorm) uniform writeonly image2D final_output;

layout(push_constant) uniform CameraVectors {
    vec3 origin, forward, up, right;
} camera_vectors;

const uint PIECE_BLOCK_WIDTH = 8; // pieces are 8x8x8 blocks
const uint CHUNK_PIECE_WIDTH = 8; // chunks are 8x8x8 pieces
const uint CHUNK_BLOCK_WIDTH = CHUNK_PIECE_WIDTH * PIECE_BLOCK_WIDTH;

const uint PIECE_BLOCK_VOLUME = PIECE_BLOCK_WIDTH * PIECE_BLOCK_WIDTH * PIECE_BLOCK_WIDTH;
const uint CHUNK_PIECE_VOLUME = CHUNK_PIECE_WIDTH * CHUNK_PIECE_WIDTH * CHUNK_PIECE_WIDTH;
const uint CHUNK_BLOCK_VOLUME = CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint ROOT_CHUNK_WIDTH = 4; // root is 64x64x64 chunks.
const uint ATLAS_CHUNK_WIDTH = 4; // atlas is 4x4x4 chunks
const uint ATLAS_CHUNK_VOLUME = ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH;
const uint UNLOADED_CHUNK_INDEX = 0xFFFF;
const uint EMPTY_CHUNK_INDEX = 0xFFFE;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;

const float PI = 3.1415926535897932384626433832795;

struct HitResult {
    uint value;
    vec3 position;
    float distance;
    uint normal;
};

#define PERFORM_BLOCK_STEP(AXIS) \
    block_coord.AXIS += step.AXIS; \
    total_step = next_block_distance.AXIS; \
    if (block_coord.AXIS == piece_exit_planes.AXIS) { break; } \
    result.value = imageLoad(block_data_atlas, block_coord + atlas_offset * ivec3(CHUNK_BLOCK_WIDTH)).r; \
    if (result.value != 0) { \
        result.normal = int(NORMAL_##AXIS) + (step.AXIS + 1) / 2;\
        break; \
    } \
    next_block_distance.AXIS += block_advance_amount.AXIS;

#define PERFORM_PIECE_TRACE(AXIS) \
    vec3 real_pos = origin + direction * total_step; \
    vec3 fake_pos = real_pos; \
    fake_pos.AXIS += step.AXIS * 0.01; \
    block_coord = ivec3(floor(fake_pos)); \
    \
    if (step.x == 1) { \
        next_block_distance.x = (block_coord.x + 1 - real_pos.x) * block_advance_amount.x; \
        piece_exit_planes.x = (piece_coord.x + 1) * int(PIECE_BLOCK_WIDTH); \
    } else { \
        next_block_distance.x = (real_pos.x - block_coord.x) * block_advance_amount.x; \
        piece_exit_planes.x = piece_coord.x * int(PIECE_BLOCK_WIDTH) - 1; \
    } \
    if (step.y == 1) { \
        next_block_distance.y = (block_coord.y + 1 - real_pos.y) * block_advance_amount.y; \
        piece_exit_planes.y = (piece_coord.y + 1) * int(PIECE_BLOCK_WIDTH); \
    } else { \
        next_block_distance.y = (real_pos.y - block_coord.y) * block_advance_amount.y; \
        piece_exit_planes.y = piece_coord.y * int(PIECE_BLOCK_WIDTH) - 1; \
    } \
    if (step.z == 1) { \
        next_block_distance.z = (block_coord.z + 1 - real_pos.z) * block_advance_amount.z; \
        piece_exit_planes.z = (piece_coord.z + 1) * int(PIECE_BLOCK_WIDTH); \
    } else { \
        next_block_distance.z = (real_pos.z - block_coord.z) * block_advance_amount.z; \
        piece_exit_planes.z = piece_coord.z * int(PIECE_BLOCK_WIDTH) - 1; \
    } \
    next_block_distance += vec3(total_step); \
    block_coord %= ivec3(CHUNK_BLOCK_WIDTH); \
    result.value = imageLoad(block_data_atlas, block_coord + atlas_offset * ivec3(CHUNK_BLOCK_WIDTH)).r; \
    if (result.value == 0) { for (int i = 0; i < 128; i++) { \
        if (next_block_distance.x < next_block_distance.y) { \
            if (next_block_distance.x < next_block_distance.z) { \
                PERFORM_BLOCK_STEP(x); \
            } else { \
                PERFORM_BLOCK_STEP(z); \
            } \
        } else { \
            if (next_block_distance.y < next_block_distance.z) { \
                PERFORM_BLOCK_STEP(y); \
            } else { \
                PERFORM_BLOCK_STEP(z); \
            } \
        } \
    } } else { \
        result.normal = int(NORMAL_##AXIS) + (step.AXIS + 1) / 2; \
    }

#define PERFORM_PIECE_STEP(AXIS) \
    piece_coord.AXIS += step.AXIS; \
    total_step = next_piece_distance.AXIS; \
    if (piece_coord.AXIS < 0 || piece_coord.AXIS == CHUNK_PIECE_WIDTH) { break; } \
    result.value = imageLoad(piece_mip_atlas, piece_coord + atlas_offset * ivec3(CHUNK_PIECE_WIDTH)).r; \
    if (result.value != 0) { \
        PERFORM_PIECE_TRACE(AXIS); \
        if (result.value != 0) { break; } \
    } \
    next_piece_distance.AXIS += piece_advance_amount.AXIS;

#define PERFORM_CHUNK_TRACE(AXIS) \
    vec3 real_pos = origin + direction * total_step; \
    vec3 fake_pos = real_pos; \
    fake_pos.AXIS += step.AXIS * 0.01; \
    block_coord = ivec3(floor(fake_pos)); \
    piece_coord = block_coord / ivec3(CHUNK_PIECE_WIDTH); \
    real_pos /= PIECE_BLOCK_WIDTH; \
    \
    if (step.x == 1) { \
        next_piece_distance.x = (piece_coord.x + 1 - real_pos.x) * piece_advance_amount.x; \
    } else { \
        next_piece_distance.x = (real_pos.x - piece_coord.x) * piece_advance_amount.x; \
    } \
    if (step.y == 1) { \
        next_piece_distance.y = (piece_coord.y + 1 - real_pos.y) * piece_advance_amount.y; \
    } else { \
        next_piece_distance.y = (real_pos.y - piece_coord.y) * piece_advance_amount.y; \
    } \
    if (step.z == 1) { \
        next_piece_distance.z = (piece_coord.z + 1 - real_pos.z) * piece_advance_amount.z; \
    } else { \
        next_piece_distance.z = (real_pos.z - piece_coord.z) * piece_advance_amount.z; \
    } \
    next_piece_distance += vec3(total_step); \
    piece_coord = block_coord % ivec3(CHUNK_BLOCK_WIDTH) / ivec3(PIECE_BLOCK_WIDTH); \
    result.value = imageLoad(piece_mip_atlas, piece_coord + atlas_offset * ivec3(CHUNK_PIECE_WIDTH)).r; \
    if (result.value != 0) { \
        PERFORM_PIECE_TRACE(AXIS); \
    } \
    if (result.value == 0) { for (int i = 0; i < 128; i++) { \
        if (next_piece_distance.x < next_piece_distance.y) { \
            if (next_piece_distance.x < next_piece_distance.z) { \
                PERFORM_PIECE_STEP(x); \
            } else { \
                PERFORM_PIECE_STEP(z); \
            } \
        } else { \
            if (next_piece_distance.y < next_piece_distance.z) { \
                PERFORM_PIECE_STEP(y); \
            } else { \
                PERFORM_PIECE_STEP(z); \
            } \
        } \
    } }

#define PERFORM_CHUNK_STEP(AXIS) \
    chunk_coord.AXIS += step.AXIS; \
    total_step = next_chunk_distance.AXIS; \
    if (chunk_coord.AXIS < 0 || chunk_coord.AXIS == ROOT_CHUNK_WIDTH) { break; } \
    chunk_index = imageLoad(root, chunk_coord).r; \
    if (chunk_coord.z > 0) { \
        chunk_index = EMPTY_CHUNK_INDEX; \
    } \
    if (chunk_index != EMPTY_CHUNK_INDEX) { \
        atlas_offset.x = int(chunk_index % ATLAS_CHUNK_WIDTH); \
        atlas_offset.y = int(chunk_index / ATLAS_CHUNK_WIDTH % ATLAS_CHUNK_WIDTH); \
        atlas_offset.z = int(chunk_index / ATLAS_CHUNK_WIDTH / ATLAS_CHUNK_WIDTH); \
        PERFORM_CHUNK_TRACE(AXIS) \
    } \
    if (result.value != 0) { break; } \
    next_chunk_distance.AXIS += chunk_advance_amount.AXIS;

HitResult trace_ray(vec3 origin, vec3 direction) {
    HitResult result;
    float total_step = 0.0;
    ivec3 block_coord, piece_coord, atlas_offset;
    ivec3 piece_exit_planes, chunk_exit_planes;
    vec3 next_piece_distance, next_block_distance;
    ivec3 chunk_coord = ivec3(floor(origin / CHUNK_BLOCK_WIDTH));
    uint chunk_index;

    ivec3 step = ivec3(
        direction.x < 0 ? -1 : 1,
        direction.y < 0 ? -1 : 1,
        direction.z < 0 ? -1 : 1
    );
    // How much we need to move along the vector to advance the current block 
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 block_advance_amount = abs(vec3(
        1.0 / (direction.x + 1e-8),
        1.0 / (direction.y + 1e-8),
        1.0 / (direction.z + 1e-8)
    ));
    // How much we need to move along the vector to advance the current piece 
    // coordinate by *exactly* 1 piece in the x, y, and z directions. 
    vec3 piece_advance_amount = block_advance_amount * vec3(PIECE_BLOCK_WIDTH);
    vec3 chunk_advance_amount = block_advance_amount * vec3(CHUNK_BLOCK_WIDTH);

    vec3 next_chunk_distance = vec3(0);
    if (step.x == 1) {
        next_chunk_distance.x = (CHUNK_BLOCK_WIDTH - mod(origin.x, CHUNK_BLOCK_WIDTH)) * block_advance_amount.x;
    } else {
        next_chunk_distance.x = mod(origin.x, CHUNK_BLOCK_WIDTH) * block_advance_amount.x;
    }
    if (step.y == 1) {
        next_chunk_distance.y = (CHUNK_BLOCK_WIDTH - mod(origin.y, CHUNK_BLOCK_WIDTH)) * block_advance_amount.y;
    } else {
        next_chunk_distance.y = mod(origin.y, CHUNK_BLOCK_WIDTH) * block_advance_amount.y;
    }
    if (step.z == 1) {
        next_chunk_distance.z = (CHUNK_BLOCK_WIDTH - mod(origin.z, CHUNK_BLOCK_WIDTH)) * block_advance_amount.z;
    } else {
        next_chunk_distance.z = mod(origin.z, CHUNK_BLOCK_WIDTH) * block_advance_amount.z;
    }

    result.value = 0;
    chunk_index = imageLoad(root, chunk_coord).r;
    if (chunk_coord.z > 0) {
        chunk_index = EMPTY_CHUNK_INDEX;
    }
    if (chunk_index != EMPTY_CHUNK_INDEX) {
        atlas_offset.x = int(chunk_index % ATLAS_CHUNK_WIDTH);
        atlas_offset.y = int(chunk_index / ATLAS_CHUNK_WIDTH % ATLAS_CHUNK_WIDTH);
        atlas_offset.z = int(chunk_index / ATLAS_CHUNK_WIDTH / ATLAS_CHUNK_WIDTH);
        PERFORM_CHUNK_TRACE(x);
    }
    if (result.value == 0) { for (int i = 0; i < 128; i++) {
        if (next_chunk_distance.x < next_chunk_distance.y) {
            if (next_chunk_distance.x < next_chunk_distance.z) {
                PERFORM_CHUNK_STEP(x);
            } else {
                PERFORM_CHUNK_STEP(z);
            }
        } else {
            if (next_chunk_distance.y < next_chunk_distance.z) {
                PERFORM_CHUNK_STEP(y);
            } else {
                PERFORM_CHUNK_STEP(z);
            }
        }
    } }

    result.distance = total_step;
    result.position = origin + direction * total_step;

    if (result.normal == NORMAL_x) {
        result.position += vec3(0.02, 0, 0);
    } else if (result.normal == NORMAL_x + 1) {
        result.position -= vec3(0.02, 0, 0);
    } else if (result.normal == NORMAL_y) {
        result.position += vec3(0, 0.02, 0);
    } else if (result.normal == NORMAL_y + 1) {
        result.position -= vec3(0, 0.02, 0);
    } else if (result.normal == NORMAL_z) {
        result.position += vec3(0, 0, 0.02);
    } else if (result.normal == NORMAL_z + 1) {
        result.position -= vec3(0, 0, 0.02);
    }

    return result;
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

HitResult trace_sun(HitResult from, vec3 direction) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    return trace_ray(from.position, normalize(direction + vec3(r1, r2, 0) * 0.05));
}

HitResult trace_diffuse(HitResult from) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    float theta1 = PI * 2.0 * r1;
    float theta2 = acos(1.0 - 2.0 * r2);
    // Random point on sphere.
    vec3 direction = vec3(
        sin(theta1) * sin(theta2),
        cos(theta1) * sin(theta2),
        cos(theta2)
    );
    if (from.normal == NORMAL_x) {
        direction += vec3(1, 0, 0);
    } else if (from.normal == NORMAL_x + 1) {
        direction -= vec3(1, 0, 0);
    } else if (from.normal == NORMAL_y) {
        direction += vec3(0, 1, 0);
    } else if (from.normal == NORMAL_y + 1) {
        direction -= vec3(0, 1, 0);
    } else if (from.normal == NORMAL_z) {
        direction += vec3(0, 0, 1);
    } else if (from.normal == NORMAL_z + 1) {
        direction -= vec3(0, 0, 1);
    }
    return trace_ray(from.position, normalize(direction));
}

vec3 get_material_albedo(uint material) {
    switch (material) {
        case 0:
        return vec3(1, 0, 1);
        case 1:
        return vec3(0.8);
        case 2:
        return vec3(0.4, 0.3, 0.2);
        case 3:
        return vec3(0.2, 0.8, 0.2);
        case 4:
        return vec3(0.2, 0.4, 0.9);
        case 5:
        return vec3(0.2, 0.8, 0.7);
        case 6:
        return vec3(0.9, 0.7, 0.2);
        case 7:
        return vec3(0.8, 0.2, 0.7);
        case 8:
        return vec3(0.2, 0.2, 0.2);
    }
}

vec3 get_material_emission(uint material) {
    switch (material) {
        case 0:
        return vec3(0);
        case 1:
        return vec3(0);
        case 2:
        return vec3(1.9, 0.8, 0.4);
        case 3:
        return vec3(0);
        case 4:
        return vec3(0);
        case 5:
        return vec3(0);
        case 6:
        return vec3(0);
        case 7:
        return vec3(0);
        case 8:
        return vec3(0);
    }
}

vec3 debug_normal(uint normal) {
    vec3 color = vec3(1);
    if (normal % 2 == 1) {
        normal -= 1;
        color *= 0.5;
    }
    if (normal == NORMAL_x) {
        color *= vec3(1, 0, 0);
    } else if (normal == NORMAL_y) {
        color *= vec3(0, 1, 0);
    } else if (normal == NORMAL_z) {
        color *= vec3(0, 0, 1);
    }
    return color;
}

void main() {
    vec3 ray_start = camera_vectors.origin;

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(imageSize(final_output)) * 2.0 - vec2(1);
    // Must be normalized. 
    vec3 ray_direction = normalize(
        camera_vectors.forward
        + screen_pos.x * camera_vectors.right
        + screen_pos.y * camera_vectors.up
    );

    vec3 skylight = vec3(0.2, 0.4, 0.8);
    vec3 sunlight = vec3(0.6);
    vec3 sunangle = vec3(1, 2, 1);
    vec3 color = skylight;
    HitResult primary = trace_ray(camera_vectors.origin, ray_direction);
    if (primary.value > 0) {
        color = vec3(0.0);
        vec3 albedo1 = get_material_albedo(primary.value);
        HitResult sun1 = trace_sun(primary, sunangle);
        if (sun1.value == 0) {
            color += albedo1 * sunlight;
        }
        HitResult dif1 = trace_diffuse(primary);
        if (dif1.value == 0) {
            color += albedo1 * skylight;
        } else {
            vec3 color2 = vec3(0.0);
            vec3 albedo2 = get_material_albedo(dif1.value);
            HitResult sun2 = trace_sun(dif1, sunangle);
            if (sun2.value == 0) {
                color2 += albedo2 * sunlight;
            }
            HitResult dif2 = trace_diffuse(dif1);
            if (dif2.value == 0) {
                color2 += albedo2 * skylight;
            } else {
                // vec3 color3 = vec3(0.0);
                // vec3 albedo3 = get_material_albedo(dif2.value);
                // HitResult sun3 = trace_sun(dif2, sunangle);
                // if (sun3.value == 0) {
                    // color3 += albedo3 * sunlight;
                // }
                // HitResult dif3 = trace_diffuse(dif1);
                // if (dif3.value == 0) {
                    // color3 += albedo3 * skylight;
                // }
                // color3 += get_material_emission(dif2.value);
                // color2 += albedo2 * color3;
            }
            color2 += get_material_emission(dif1.value);
            color += albedo1 * color2;
        }
        color += get_material_emission(primary.value);
    }

    imageStore(
        final_output,
        ivec2(gl_GlobalInvocationID.xy), 
        vec4(color, 1.0)
    );
}