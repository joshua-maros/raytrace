#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r16ui) uniform uimage3D l1;
layout(set = 0, binding = 1, r16ui) uniform uimage3D l2;
layout(set = 0, binding = 2, rgba8_snorm) uniform writeonly image2D final_output;

layout(push_constant) uniform CameraVectors {
    vec3 origin, forward, up, right;
} camera_vectors;

const uint WORLD_SIZE = 64;
const uint L2_STEP = 8;
const float L2_STEPF = L2_STEP;
const uint L2_SIZE = WORLD_SIZE / L2_STEP;

const uint MODE_L1 = 0;
const uint MODE_L2 = 1;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;
const uint POSITION_PRECISION = 64; // How much to scale hit result position by.

const float PI = 3.1415926535897932384626433832795;

struct HitResult {
    uint value;
    vec3 position;
    float distance;
    uint normal;
};

#define PERFORM_L1_STEP(AXIS) \
    l1_pos.AXIS += l1_step.AXIS; \
    if (l1_pos.AXIS == l1_exit_planes.AXIS) { break; } \
    total_step = l1_to_boundary.AXIS; \
    result.value = imageLoad(l1, l1_pos).r; \
    if (result.value != 0) { \
        result.normal = NORMAL_##AXIS + (l1_step.AXIS + 1) / 2; \
        break; \
    } \
    l1_to_boundary.AXIS += l1_advance_amount.AXIS;

#define PERFORM_L1_TRACE(AXIS) \
        ivec3 l1_exit_planes = ivec3( \
            l2_pos.x * L2_STEP + (l1_step.x == 1 ? L2_STEP : - 1), \
            l2_pos.y * L2_STEP + (l1_step.y == 1 ? L2_STEP : - 1), \
            l2_pos.z * L2_STEP + (l1_step.z == 1 ? L2_STEP : - 1) \
        ); \
        vec3 exact_pos = origin + direction * (total_step + 0.01); \
        l1_pos = ivec3( \
            floor(exact_pos.x), \
            floor(exact_pos.y), \
            floor(exact_pos.z) \
        ); \
        \
        vec3 l1_to_boundary = vec3(0); \
        if (l1_step.x == 1) { \
            l1_to_boundary.x =  \
                (1.0 - mod(exact_pos.x, 1.0))  \
                * l1_advance_amount.x; \
        } else { \
            l1_to_boundary.x =  \
                mod(exact_pos.x, 1.0) * l1_advance_amount.x; \
        } \
        if (l1_step.y == 1) { \
            l1_to_boundary.y =  \
                (1.0 - mod(exact_pos.y, 1.0))  \
                * l1_advance_amount.y; \
        } else { \
            l1_to_boundary.y =  \
                mod(exact_pos.y, 1.0) * l1_advance_amount.y; \
        } \
        if (l1_step.z == 1) { \
            l1_to_boundary.z =  \
                (1.0 - mod(exact_pos.z, 1.0))  \
                * l1_advance_amount.z; \
        } else { \
            l1_to_boundary.z =  \
                mod(exact_pos.z, 1.0) * l1_advance_amount.z; \
        } \
        l1_to_boundary += vec3(total_step); \
        \
        result.value = imageLoad(l1, l1_pos).r; \
        if (result.value == 0) { while (true) { \
            if (l1_to_boundary.x < l1_to_boundary.y) { \
                if (l1_to_boundary.x < l1_to_boundary.z) { \
                    PERFORM_L1_STEP(x); \
                } else { \
                    PERFORM_L1_STEP(z); \
                } \
            } else { \
                if (l1_to_boundary.y < l1_to_boundary.z) { \
                    PERFORM_L1_STEP(y); \
                } else { \
                    PERFORM_L1_STEP(z); \
                } \
            } \
        } } else { \
            result.normal = NORMAL_##AXIS + (l1_step.AXIS + 1) / 2; \
        }

#define PERFORM_L2_STEP(AXIS) \
    l2_pos.AXIS += l1_step.AXIS; \
    if (l2_pos.AXIS > L2_SIZE || l2_pos.AXIS < 0) { break; } \
    result.value = imageLoad(l2, l2_pos).r; \
    if (result.value != 0) { \
        PERFORM_L1_TRACE(AXIS); \
        if (result.value != 0) { break; } \
    } \
    l2_to_boundary.AXIS += l2_advance_amount.AXIS ;

HitResult trace_ray(vec3 origin, vec3 direction) {
    ivec3 l1_pos = ivec3(0);
    ivec3 l2_pos = ivec3(
        floor(origin.x),
        floor(origin.y),
        floor(origin.z)
    ) / ivec3(L2_STEP);
    ivec3 l1_step = ivec3(
        direction.x < 0 ? -1 : 1,
        direction.y < 0 ? -1 : 1,
        direction.z < 0 ? -1 : 1
    );
    ivec3 l2_step = l1_step * ivec3(L2_STEP);

    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 l1_advance_amount = abs(vec3(
        1.0 / (direction.x + 1e-8),
        1.0 / (direction.y + 1e-8),
        1.0 / (direction.z + 1e-8)
    ));
    // How much we need to move along the vector to advance the current voxel
    // coordinate by *exactly* L2_STEPF in the x, y, and z directions. 
    vec3 l2_advance_amount = l1_advance_amount * vec3(L2_STEPF);
    // How much we need to move along the vector to reach the next voxel in the
    // x, y, and z directions. In this case, since it is l2, 'voxel' refers to
    // an 8x8x8 segment.

    vec3 l2_to_boundary = vec3(0);
    if (l1_step.x == 1) {
        l2_to_boundary.x = (L2_STEPF - mod(origin.x, L2_STEPF)) * l1_advance_amount.x;
    } else {
        l2_to_boundary.x = mod(origin.x, L2_STEPF) * l1_advance_amount.x;
    }
    if (l1_step.y == 1) {
        l2_to_boundary.y = (L2_STEPF - mod(origin.y, L2_STEPF)) * l1_advance_amount.y;
    } else {
        l2_to_boundary.y = mod(origin.y, L2_STEPF) * l1_advance_amount.y;
    }
    if (l1_step.z == 1) {
        l2_to_boundary.z = (L2_STEPF - mod(origin.z, L2_STEPF)) * l1_advance_amount.z;
    } else {
        l2_to_boundary.z = mod(origin.z, L2_STEPF) * l1_advance_amount.z;
    }

    HitResult result;
    float total_step = 0.0;
    uint mode = MODE_L1;
    result.value = imageLoad(l2, l2_pos).r;
    if (result.value != 0) {
        PERFORM_L1_TRACE(x);
    }
    if (result.value == 0) { while (true) {
        if (l2_to_boundary.x < l2_to_boundary.y) {
            if (l2_to_boundary.x < l2_to_boundary.z) {
                PERFORM_L2_STEP(x);
            } else {
                PERFORM_L2_STEP(z);
            }
        } else {
            if (l2_to_boundary.y < l2_to_boundary.z) {
                PERFORM_L2_STEP(y);
            } else {
                PERFORM_L2_STEP(z);
            }
        }
    } }
    result.distance = total_step;
    result.position = origin + direction * result.distance;

    return result;
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

HitResult trace_sun(HitResult from, vec3 direction) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    return trace_ray(from.position, normalize(direction + vec3(r1, r2, 0) * 0.05));
}

HitResult trace_diffuse(HitResult from) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    float theta1 = PI * 2.0 * r1;
    float theta2 = acos(1.0 - 2.0 * r2);
    // Random point on sphere.
    vec3 direction = vec3(
        sin(theta1) * sin(theta2),
        cos(theta1) * sin(theta2),
        cos(theta2)
    );
    if (from.normal == NORMAL_x) {
        direction += vec3(1, 0, 0);
    } else if (from.normal == NORMAL_x + 1) {
        direction -= vec3(1, 0, 0);
    } else if (from.normal == NORMAL_y) {
        direction += vec3(0, 1, 0);
    } else if (from.normal == NORMAL_y + 1) {
        direction -= vec3(0, 1, 0);
    } else if (from.normal == NORMAL_z) {
        direction += vec3(0, 0, 1);
    } else if (from.normal == NORMAL_z + 1) {
        direction -= vec3(0, 0, 1);
    }
    return trace_ray(from.position, normalize(direction));
}

vec3 get_material_albedo(uint material) {
    switch (material) {
        case 0:
        return vec3(1, 0, 1);
        case 1:
        return vec3(0.8);
        case 2:
        return vec3(0.4, 0.3, 0.2);
        case 3:
        return vec3(0.2, 0.8, 0.2);
        case 4:
        return vec3(0.2, 0.4, 0.9);
        case 5:
        return vec3(0.2, 0.8, 0.7);
        case 6:
        return vec3(0.9, 0.7, 0.2);
        case 7:
        return vec3(0.8, 0.2, 0.7);
        case 8:
        return vec3(0.2, 0.2, 0.2);
    }
}

vec3 get_material_emission(uint material) {
    switch (material) {
        case 0:
        return vec3(0);
        case 1:
        return vec3(0);
        case 2:
        return vec3(1.9, 0.8, 0.4);
        case 3:
        return vec3(0);
        case 4:
        return vec3(0);
        case 5:
        return vec3(0);
        case 6:
        return vec3(0);
        case 7:
        return vec3(0);
        case 8:
        return vec3(0);
    }
}

void main() {
    vec3 ray_start = camera_vectors.origin;

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(imageSize(final_output)) * 2.0 - vec2(1);
    // Must be normalized. 
    vec3 ray_direction = normalize(
        camera_vectors.forward
        + screen_pos.x * camera_vectors.right
        + screen_pos.y * camera_vectors.up
    );

    vec3 skylight = vec3(0.2, 0.4, 0.8);
    vec3 sunlight = vec3(0.6);
    vec3 sunangle = vec3(1, 2, 1);
    vec3 color = skylight;
    HitResult primary = trace_ray(camera_vectors.origin, ray_direction);
    if (primary.value > 0) {
        color = vec3(0.0);
        vec3 albedo1 = get_material_albedo(primary.value);
        HitResult sun1 = trace_sun(primary, sunangle);
        if (sun1.value == 0) {
            color += albedo1 * sunlight;
        }
        HitResult dif1 = trace_diffuse(primary);
        if (dif1.value == 0) {
            color += albedo1 * skylight;
        } else {
            vec3 color2 = vec3(0.0);
            vec3 albedo2 = get_material_albedo(dif1.value);
            HitResult sun2 = trace_sun(dif1, sunangle);
            if (sun2.value == 0) {
                color2 += albedo2 * sunlight;
            }
            HitResult dif2 = trace_diffuse(dif1);
            if (dif2.value == 0) {
                color2 += albedo2 * skylight;
            } else {
                vec3 color3 = vec3(0.0);
                vec3 albedo3 = get_material_albedo(dif2.value);
                HitResult sun3 = trace_sun(dif2, sunangle);
                if (sun3.value == 0) {
                    color3 += albedo3 * sunlight;
                }
                HitResult dif3 = trace_diffuse(dif1);
                if (dif3.value == 0) {
                    color3 += albedo3 * skylight;
                }
                color3 += get_material_emission(dif2.value);
                color2 += albedo2 * color3;
            }
            color2 += get_material_emission(dif1.value);
            color += albedo1 * color2;
        }
        color += get_material_emission(primary.value);
    }

    imageStore(
        final_output,
        ivec2(gl_GlobalInvocationID.xy), 
        vec4(color, 1.0)
    );
}