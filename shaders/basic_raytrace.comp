#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r16ui) uniform uimage3D block_data_atlas;
layout(set = 0, binding = 1, r16ui) uniform uimage3D piece_mip_atlas;
layout(set = 0, binding = 2, r16ui) uniform uimage3D root;
layout(set = 0, binding = 3, rgba8_snorm) uniform writeonly image2D final_output;

layout(push_constant) uniform CameraVectors {
    vec3 origin, forward, up, right;
} camera_vectors;

const uint PIECE_BLOCK_WIDTH = 8; // pieces are 8x8x8 blocks
const uint CHUNK_PIECE_WIDTH = 8; // chunks are 8x8x8 pieces
const uint CHUNK_BLOCK_WIDTH = CHUNK_PIECE_WIDTH * PIECE_BLOCK_WIDTH;

const uint PIECE_BLOCK_VOLUME = PIECE_BLOCK_WIDTH * PIECE_BLOCK_WIDTH * PIECE_BLOCK_WIDTH;
const uint CHUNK_PIECE_VOLUME = CHUNK_PIECE_WIDTH * CHUNK_PIECE_WIDTH * CHUNK_PIECE_WIDTH;
const uint CHUNK_BLOCK_VOLUME = CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH * CHUNK_BLOCK_WIDTH;

const uint ROOT_CHUNK_WIDTH = 64; // root is 64x64x64 chunks.
const uint ATLAS_CHUNK_WIDTH = 4; // atlas is 4x4x4 chunks
const uint ATLAS_CHUNK_VOLUME = ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH * ATLAS_CHUNK_WIDTH;

const uint NORMAL_x = 0;
const uint NORMAL_y = 2;
const uint NORMAL_z = 4;

const float PI = 3.1415926535897932384626433832795;

struct HitResult {
    uint value;
    vec3 position;
    float distance;
    uint normal;
};

// breaks if a solid block is hit, continues if not. updates total_step in both cases.
#define PERFORM_BLOCK_STEP(AXIS) \
    block_coord.AXIS += step.AXIS; \
    total_step = next_block_distance.AXIS; \
    if (block_coord.AXIS == piece_exit_planes.AXIS) { break; } \
    result.value = imageLoad(block_data_atlas, block_coord).r; \
    if (result.value != 0) { \
        result.normal = NORMAL_##AXIS + (step.AXIS + 1) / 2; \
        break; \
    } \
    next_block_distance.AXIS += block_advance_amount.AXIS;

// result contains any block found in this piece. If it is 0, no block was found in this piece.
// total_step is updated to how far the ray went through the piece. If no block was found,
// total_step will be the distance from the ray origin to the end of the piece.
#define PERFORM_PIECE_TRACE(AXIS) \
    ivec3 piece_exit_planes = ivec3( \
        piece_coord.x * PIECE_BLOCK_WIDTH + (step.x == 1 ? PIECE_BLOCK_WIDTH : -1), \
        piece_coord.y * PIECE_BLOCK_WIDTH + (step.y == 1 ? PIECE_BLOCK_WIDTH : -1), \
        piece_coord.z * PIECE_BLOCK_WIDTH + (step.z == 1 ? PIECE_BLOCK_WIDTH : -1) \
    ); \
    vec3 exact_pos = origin + direction * (total_step + 0.01); \
    block_coord = ivec3( \
        floor(exact_pos.x), \
        floor(exact_pos.y), \
        floor(exact_pos.z) \
    ) % ivec3(CHUNK_BLOCK_WIDTH); \
    \
    vec3 next_block_distance = vec3(0); \
    if (step.x == 1) { \
        next_block_distance.x =  (1.0 - mod(exact_pos.x, 1.0)) * block_advance_amount.x; \
    } else { \
        next_block_distance.x =  mod(exact_pos.x, 1.0) * block_advance_amount.x; \
    } \
    if (step.y == 1) { \
        next_block_distance.y = (1.0 - mod(exact_pos.y, 1.0)) * block_advance_amount.y; \
    } else { \
        next_block_distance.y = mod(exact_pos.y, 1.0) * block_advance_amount.y; \
    } \
    if (step.z == 1) { \
        next_block_distance.z = (1.0 - mod(exact_pos.z, 1.0)) * block_advance_amount.z; \
    } else { \
        next_block_distance.z = mod(exact_pos.z, 1.0) * block_advance_amount.z; \
    } \
    next_block_distance += vec3(total_step); \
    \
    result.value = imageLoad(block_data_atlas, block_coord).r; \
    if (result.value == 0) { while (true) { \
        if (next_block_distance.x < next_block_distance.y) { \
            if (next_block_distance.x < next_block_distance.z) { \
                PERFORM_BLOCK_STEP(x); \
            } else { \
                PERFORM_BLOCK_STEP(z); \
            } \
        } else { \
            if (next_block_distance.y < next_block_distance.z) { \
                PERFORM_BLOCK_STEP(y); \
            } else { \
                PERFORM_BLOCK_STEP(z); \
            } \
        } \
    } } else { \
        result.normal = NORMAL_##AXIS + (step.AXIS + 1) / 2; \
    }

// breaks if a solid block is hit, continues if not. updates total_step in both cases.
#define PERFORM_PIECE_STEP(AXIS) \
    piece_coord.AXIS += step.AXIS; \
    if (piece_coord.AXIS > CHUNK_PIECE_WIDTH || piece_coord.AXIS < 0) { \
        total_step = next_piece_distance.AXIS; \
        break; \
    } \
    result.value = imageLoad(piece_mip_atlas, piece_coord).r; \
    if (result.value != 0) { \
        PERFORM_PIECE_TRACE(AXIS); \
        if (result.value != 0) { break; } \
    } \
    next_piece_distance.AXIS += piece_advance_amount.AXIS;

// result contains any block found in this chunk. If it is 0, no block was found in this chunk.
// total_step is updated to how far the ray went through the chunk. If no block was found,
// total_step will be the distance from the ray origin to the end of the chunk.
#define PERFORM_CHUNK_TRACE() \
    vec3 exact_pos = origin + direction * (total_step + 0.01); \
    piece_coord = ivec3( \
        floor(exact_pos.x), \
        floor(exact_pos.y), \
        floor(exact_pos.z) \
    ) % ivec3(CHUNK_BLOCK_WIDTH) / ivec3(PIECE_BLOCK_WIDTH); \
    /* How much we need to move along the vector to reach the next chunk in the */ \
    /* x, y, and z directions. */ \
    vec3 next_piece_distance = vec3(0); \
    if (step.x == 1) { \
        next_piece_distance.x = (PIECE_BLOCK_WIDTH - mod(exact_pos.x, PIECE_BLOCK_WIDTH)) * block_advance_amount.x; \
    } else { \
        next_piece_distance.x = mod(exact_pos.x, PIECE_BLOCK_WIDTH) * block_advance_amount.x; \
    } \
    if (step.y == 1) { \
        next_piece_distance.y = (PIECE_BLOCK_WIDTH - mod(exact_pos.y, PIECE_BLOCK_WIDTH)) * block_advance_amount.y; \
    } else { \
        next_piece_distance.y = mod(exact_pos.y, PIECE_BLOCK_WIDTH) * block_advance_amount.y; \
    } \
    if (step.z == 1) { \
        next_piece_distance.z = (PIECE_BLOCK_WIDTH - mod(exact_pos.z, PIECE_BLOCK_WIDTH)) * block_advance_amount.z; \
    } else { \
        next_piece_distance.z = mod(exact_pos.z, PIECE_BLOCK_WIDTH) * block_advance_amount.z; \
    } \
    next_piece_distance += vec3(total_step); \
    \
    result.value = imageLoad(piece_mip_atlas, piece_coord).r; \
    if (result.value != 0) { \
        PERFORM_PIECE_TRACE(x); /* todo: proper axis */ \
    } \
    if (result.value == 0) { while (true) { \
        if (next_piece_distance.x < next_piece_distance.y) { \
            if (next_piece_distance.x < next_piece_distance.z) { \
                PERFORM_PIECE_STEP(x); \
            } else { \
                PERFORM_PIECE_STEP(z); \
            } \
        } else { \
            if (next_piece_distance.y < next_piece_distance.z) { \
                PERFORM_PIECE_STEP(y); \
            } else { \
                PERFORM_PIECE_STEP(z); \
            } \
        } \
    } }

HitResult trace_ray(vec3 origin, vec3 direction) {
    HitResult result;
    float total_step = 0.0;
    ivec3 block_coord = ivec3(0);
    ivec3 piece_coord = ivec3(
        floor(origin.x),
        floor(origin.y),
        floor(origin.z)
    ) / ivec3(PIECE_BLOCK_WIDTH);
    ivec3 step = ivec3(
        direction.x < 0 ? -1 : 1,
        direction.y < 0 ? -1 : 1,
        direction.z < 0 ? -1 : 1
    );

    // How much we need to move along the vector to advance the current block 
    // coordinate by *exactly* 1.0 in the x, y, and z directions. 
    vec3 block_advance_amount = abs(vec3(
        1.0 / (direction.x + 1e-8),
        1.0 / (direction.y + 1e-8),
        1.0 / (direction.z + 1e-8)
    ));
    // How much we need to move along the vector to advance the current piece 
    // coordinate by *exactly* 1 piece in the x, y, and z directions. 
    vec3 piece_advance_amount = block_advance_amount * vec3(PIECE_BLOCK_WIDTH);

    { PERFORM_CHUNK_TRACE();}
    {
        vec3 exact_pos = origin + direction * (total_step + 0.1);
        origin += direction * total_step;
        total_step = 0;
        if (result.value == 0 && exact_pos.x > 0 && exact_pos.y > 0 && exact_pos.z > 0 && exact_pos.z < CHUNK_BLOCK_WIDTH) {
        }
    }

    result.distance = total_step;
    result.position = origin + direction * (total_step + 0.01);

    return result;
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

HitResult trace_sun(HitResult from, vec3 direction) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    return trace_ray(from.position, normalize(direction + vec3(r1, r2, 0) * 0.05));
}

HitResult trace_diffuse(HitResult from) {
    float r1 = random(from.position);
    float r2 = random(from.position + vec3(1.3, 1.4, 1.5));
    float theta1 = PI * 2.0 * r1;
    float theta2 = acos(1.0 - 2.0 * r2);
    // Random point on sphere.
    vec3 direction = vec3(
        sin(theta1) * sin(theta2),
        cos(theta1) * sin(theta2),
        cos(theta2)
    );
    if (from.normal == NORMAL_x) {
        direction += vec3(1, 0, 0);
    } else if (from.normal == NORMAL_x + 1) {
        direction -= vec3(1, 0, 0);
    } else if (from.normal == NORMAL_y) {
        direction += vec3(0, 1, 0);
    } else if (from.normal == NORMAL_y + 1) {
        direction -= vec3(0, 1, 0);
    } else if (from.normal == NORMAL_z) {
        direction += vec3(0, 0, 1);
    } else if (from.normal == NORMAL_z + 1) {
        direction -= vec3(0, 0, 1);
    }
    return trace_ray(from.position, normalize(direction));
}

vec3 get_material_albedo(uint material) {
    switch (material) {
        case 0:
        return vec3(1, 0, 1);
        case 1:
        return vec3(0.8);
        case 2:
        return vec3(0.4, 0.3, 0.2);
        case 3:
        return vec3(0.2, 0.8, 0.2);
        case 4:
        return vec3(0.2, 0.4, 0.9);
        case 5:
        return vec3(0.2, 0.8, 0.7);
        case 6:
        return vec3(0.9, 0.7, 0.2);
        case 7:
        return vec3(0.8, 0.2, 0.7);
        case 8:
        return vec3(0.2, 0.2, 0.2);
    }
}

vec3 get_material_emission(uint material) {
    switch (material) {
        case 0:
        return vec3(0);
        case 1:
        return vec3(0);
        case 2:
        return vec3(1.9, 0.8, 0.4);
        case 3:
        return vec3(0);
        case 4:
        return vec3(0);
        case 5:
        return vec3(0);
        case 6:
        return vec3(0);
        case 7:
        return vec3(0);
        case 8:
        return vec3(0);
    }
}

void main() {
    vec3 ray_start = camera_vectors.origin;

    vec2 screen_pos = gl_GlobalInvocationID.xy / vec2(imageSize(final_output)) * 2.0 - vec2(1);
    // Must be normalized. 
    vec3 ray_direction = normalize(
        camera_vectors.forward
        + screen_pos.x * camera_vectors.right
        + screen_pos.y * camera_vectors.up
    );

    vec3 skylight = vec3(0.2, 0.4, 0.8);
    vec3 sunlight = vec3(0.6);
    vec3 sunangle = vec3(1, 2, 1);
    vec3 color = skylight;
    HitResult primary = trace_ray(camera_vectors.origin, ray_direction);
    if (primary.value > 0) {
        color = vec3(0.0);
        vec3 albedo1 = get_material_albedo(primary.value);
        HitResult sun1 = trace_sun(primary, sunangle);
        if (sun1.value == 0) {
            color += albedo1 * sunlight;
        }
        HitResult dif1 = trace_diffuse(primary);
        if (dif1.value == 0) {
            color += albedo1 * skylight;
        } else {
            vec3 color2 = vec3(0.0);
            vec3 albedo2 = get_material_albedo(dif1.value);
            HitResult sun2 = trace_sun(dif1, sunangle);
            if (sun2.value == 0) {
                color2 += albedo2 * sunlight;
            }
            HitResult dif2 = trace_diffuse(dif1);
            if (dif2.value == 0) {
                color2 += albedo2 * skylight;
            } else {
                vec3 color3 = vec3(0.0);
                vec3 albedo3 = get_material_albedo(dif2.value);
                HitResult sun3 = trace_sun(dif2, sunangle);
                if (sun3.value == 0) {
                    color3 += albedo3 * sunlight;
                }
                HitResult dif3 = trace_diffuse(dif1);
                if (dif3.value == 0) {
                    color3 += albedo3 * skylight;
                }
                color3 += get_material_emission(dif2.value);
                color2 += albedo2 * color3;
            }
            color2 += get_material_emission(dif1.value);
            color += albedo1 * color2;
        }
        color += get_material_emission(primary.value);
    } else {
        color = vec3(primary.distance / 256.0);
    }

    imageStore(
        final_output,
        ivec2(gl_GlobalInvocationID.xy), 
        vec4(color, 1.0)
    );
}