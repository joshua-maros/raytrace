#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16ui) uniform uimage2D position;
layout(set = 0, binding = 1, r16ui) uniform uimage2D hit_result;
layout(set = 0, binding = 2, r32ui) uniform uimage3D lightmap_assignment;
layout(set = 0, binding = 3, r32ui) uniform uimage3D lightmap_table;
layout(set = 0, binding = 4, r32ui) uniform uimage1D lightmap_usage;
layout(set = 0, binding = 5, rgba8_snorm) uniform image2D image_out;
layout(set = 0, binding = 6, r32ui) uniform uimage3D lightmap_atlas_l0;
layout(set = 0, binding = 7, r32ui) uniform uimage3D lightmap_atlas_l1;
layout(set = 0, binding = 8, r32ui) uniform uimage3D lightmap_atlas_l2;

const uint LIGHTMAP_SIZE = 16;
const uint LIGHTMAP_RES_L0 = 8;
const uint LIGHTMAP_RES_L1 = 4;
const uint LIGHTMAP_RES_L2 = 2;
const uint LIGHTMAP_ATLAS_WIDTH_L0 = 8;
const uint LIGHTMAP_ATLAS_WIDTH_L1 = 16;
const uint LIGHTMAP_ATLAS_WIDTH_L2 = 32;
const uint POSITION_PRECISION = 64; 
const float POSITION_PRECISION_F = 64.0; 

const float TINY = 0.1e-2;

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec3 color = vec3(0.3569, 0.5529, 0.7137);
    uint hit_result = imageLoad(hit_result, pixel_coords).r;
    uint voxel_type = hit_result & 0x0FFF;
    uint face_normal = (hit_result & 0xF000) >> 12;
    if (hit_result != 0) {
        uvec4 position = imageLoad(position, pixel_coords).xyzw;
        color = position.xyz / POSITION_PRECISION_F / 256.0;

        uvec3 lightmap_region = uvec3(position.xyz) / uvec3(POSITION_PRECISION * 16);
        uint assignment = imageLoad(lightmap_assignment, ivec3(lightmap_region)).r;
        uint lod = (assignment & 0xF000) >> 12;
        uint tile_resolution = lod == 0 ? LIGHTMAP_RES_L0 : (lod == 1 ? LIGHTMAP_RES_L1 : LIGHTMAP_RES_L2);
        uvec3 pixel_position;

        uint index = assignment & 0x0FFF;
        uint atlas_width = lod == 0 ? LIGHTMAP_ATLAS_WIDTH_L0 : (lod == 1 ? LIGHTMAP_ATLAS_WIDTH_L1 : LIGHTMAP_ATLAS_WIDTH_L2);
        uvec2 lightmap_pos = uvec2(index % atlas_width, index / atlas_width);

        if ((face_normal & 0xE) == 0) { // Face is facing the X axis.
            // color = vec3(1, 0, 0);
            pixel_position.xy = 
                position.yz 
                % (LIGHTMAP_SIZE * POSITION_PRECISION) 
                / (POSITION_PRECISION / tile_resolution);
            pixel_position.z = (position.x / POSITION_PRECISION) % LIGHTMAP_SIZE;
        } else if ((face_normal & 0xE) == 2) { // Face is facing the Y axis.
            // color = vec3(0, 1, 0);
            pixel_position.xy = 
                position.xz
                % (LIGHTMAP_SIZE * POSITION_PRECISION) 
                / (POSITION_PRECISION / tile_resolution);
            pixel_position.z = (position.y / POSITION_PRECISION) % LIGHTMAP_SIZE + LIGHTMAP_SIZE;
        } else if ((face_normal & 0xE) == 4) { // Face is facing the Z axis.
            // color = vec3(0, 0, 1);
            pixel_position.xy = 
                position.xy
                % (LIGHTMAP_SIZE * POSITION_PRECISION) 
                / (POSITION_PRECISION / tile_resolution);
            pixel_position.z = (position.z / POSITION_PRECISION) % LIGHTMAP_SIZE + LIGHTMAP_SIZE * 2;
        }

        pixel_position.xy += lightmap_pos * LIGHTMAP_SIZE * tile_resolution;

        uint lightmap_contents;
        if (lod == 0) {
            lightmap_contents = imageLoad(lightmap_atlas_l0, ivec3(pixel_position)).r;
        } else if (lod == 1) {
            lightmap_contents = imageLoad(lightmap_atlas_l1, ivec3(pixel_position)).r;
        } else if (lod == 2) {
            lightmap_contents = imageLoad(lightmap_atlas_l2, ivec3(pixel_position)).r;
        }

        color *= (16 - lightmap_contents) / 32.0 + 0.5;
    }
    if (pixel_coords.y < 16) {
        int lightmap_level = pixel_coords.y / 4;
        uint num_lightmaps = imageLoad(lightmap_usage, lightmap_level).r;
        uint total_lightmap_capacity = 32;
        if (lightmap_level >= 1) {
            total_lightmap_capacity *= 4;
        }
        if (lightmap_level >= 2) {
            total_lightmap_capacity *= 4;
        }
        /*if (pixel_coords.x < num_lightmaps * (512 / total_lightmap_capacity)) {
            color = vec3(1.0, 0.0, 1.0);
        } else {
            color = vec3(0.2, 0.0, 0.2);
        }
        if (num_lightmaps > 99999) {
            color = vec3(0.0, 0.0, 1.0);
        }*/
        // There is no level 3. Draw the total size of all lightmaps instead.
        if (lightmap_level == 3) {
            uint total_size = imageLoad(lightmap_usage, 0).r * 16 + imageLoad(lightmap_usage, 1).r * 4 + imageLoad(lightmap_usage, 2).r;
            if (pixel_coords.x < total_size) {
                color = vec3(1.0, 0.0, 0.0);
            }
        } else {
            uint lightmap_index = pixel_coords.x / (512 / total_lightmap_capacity);
            if (imageLoad(lightmap_table, ivec3(lightmap_index, 0, lightmap_level)).r == 1) {
                color = vec3(1.0);
            } else {
                color = vec3(0.2, 0.2, 0.5);
            }
        }
    }
    if (pixel_coords.x < 256 && pixel_coords.y < 256 && false) {
        ivec3 lightmap_pos = ivec3(pixel_coords.xy * 4, 3);
        if (imageLoad(lightmap_atlas_l2, lightmap_pos).r > 0) {
            color = vec3(1);
        } else {
            color = vec3(0);
        }
    }
    imageStore(image_out, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}